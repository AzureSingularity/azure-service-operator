package microsoftazuremanagementaisupercomputer

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
    "context"
    "encoding/json"
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "github.com/Azure/go-autorest/autorest/date"
    "github.com/Azure/go-autorest/autorest/to"
    "github.com/Azure/go-autorest/tracing"
    "net/http"
)

// The package's fully qualified name.
const fqdn = "./"

        // AccountCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
        // operation.
        type AccountCreateOrUpdateFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *AccountCreateOrUpdateFuture) Result(client AccountClient) (ard AccountResourceDescription, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.AccountCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("microsoftazuremanagementaisupercomputer.AccountCreateOrUpdateFuture")
        return
        }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if ard.Response.Response, err = future.GetResult(sender); err == nil && ard.Response.Response.StatusCode != http.StatusNoContent {
            ard, err = client.CreateOrUpdateResponder(ard.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.AccountCreateOrUpdateFuture", "Result", ard.Response.Response, "Failure responding to request")
            }
            }
            return
        }

        // AccountDeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
        type AccountDeleteFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *AccountDeleteFuture) Result(client AccountClient) (ar autorest.Response, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.AccountDeleteFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("microsoftazuremanagementaisupercomputer.AccountDeleteFuture")
        return
        }
            ar.Response = future.Response()
        return
        }

        // AccountLocation describes the properties of an Account location resource.
        type AccountLocation struct {
        // Name - Name of the account location.
        Name *string `json:"name,omitempty"`
        // FailoverPriority - The failover priority of the location. Failover priority values must be unique for each of the locations associated with the account.
        FailoverPriority *int32 `json:"failoverPriority,omitempty"`
        // IsZoneRedundant - READ-ONLY; Indicates whether or not this location has AvailabilityZone enabled.
        IsZoneRedundant *bool `json:"isZoneRedundant,omitempty"`
        }

        // MarshalJSON is the custom marshaler for AccountLocation.
        func (al AccountLocation)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(al.Name != nil) {
                objectMap["name"] = al.Name
                }
                if(al.FailoverPriority != nil) {
                objectMap["failoverPriority"] = al.FailoverPriority
                }
                return json.Marshal(objectMap)
        }

        // AccountPatchProperties describes all properties which can be updated for a Singularity account resource.
        type AccountPatchProperties struct {
        // Description - User-friendly description of an account.
        Description *string `json:"description,omitempty"`
        SchedulingPolicy *SchedulingPolicy `json:"schedulingPolicy,omitempty"`
        IdleResourcesHandlingPolicy *IdleResourcesHandlingPolicy `json:"idleResourcesHandlingPolicy,omitempty"`
        // Locations - The collection of account locations.
        Locations *[]AccountLocation `json:"locations,omitempty"`
        NetworkSettings *NetworkSettings `json:"networkSettings,omitempty"`
        }

        // AccountProperties describes the properties of an Account resource.
        type AccountProperties struct {
        // ProvisioningState - Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled', 'ProvisioningStateCreating', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting'
        ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
        // Description - User-friendly description of an account.
        Description *string `json:"description,omitempty"`
        // Status - Possible values include: 'Creating', 'Created', 'Updating', 'Deleting', 'Failed'
        Status AccountStatus `json:"status,omitempty"`
        SchedulingPolicy *SchedulingPolicy `json:"schedulingPolicy,omitempty"`
        IdleResourcesHandlingPolicy *IdleResourcesHandlingPolicy `json:"idleResourcesHandlingPolicy,omitempty"`
        // StatusDetails - READ-ONLY; Gives additional information about the current status of an account.
        StatusDetails *string `json:"statusDetails,omitempty"`
        // Locations - The collection of account locations.
        Locations *[]AccountLocation `json:"locations,omitempty"`
        NetworkSettings *NetworkSettings `json:"networkSettings,omitempty"`
        }

        // MarshalJSON is the custom marshaler for AccountProperties.
        func (ap AccountProperties)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(ap.ProvisioningState != "") {
                objectMap["provisioningState"] = ap.ProvisioningState
                }
                if(ap.Description != nil) {
                objectMap["description"] = ap.Description
                }
                if(ap.Status != "") {
                objectMap["status"] = ap.Status
                }
                if(ap.SchedulingPolicy != nil) {
                objectMap["schedulingPolicy"] = ap.SchedulingPolicy
                }
                if(ap.IdleResourcesHandlingPolicy != nil) {
                objectMap["idleResourcesHandlingPolicy"] = ap.IdleResourcesHandlingPolicy
                }
                if(ap.Locations != nil) {
                objectMap["locations"] = ap.Locations
                }
                if(ap.NetworkSettings != nil) {
                objectMap["networkSettings"] = ap.NetworkSettings
                }
                return json.Marshal(objectMap)
        }

        // AccountQuotaPolicyCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
        // long-running operation.
        type AccountQuotaPolicyCreateOrUpdateFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *AccountQuotaPolicyCreateOrUpdateFuture) Result(client AccountQuotaPolicyClient) (aqprd AccountQuotaPolicyResourceDescription, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.AccountQuotaPolicyCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("microsoftazuremanagementaisupercomputer.AccountQuotaPolicyCreateOrUpdateFuture")
        return
        }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if aqprd.Response.Response, err = future.GetResult(sender); err == nil && aqprd.Response.Response.StatusCode != http.StatusNoContent {
            aqprd, err = client.CreateOrUpdateResponder(aqprd.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.AccountQuotaPolicyCreateOrUpdateFuture", "Result", aqprd.Response.Response, "Failure responding to request")
            }
            }
            return
        }

        // AccountQuotaPolicyPatchProperties describes all properties which can be updated for a Singularity account
        // quota policy resource.
        type AccountQuotaPolicyPatchProperties struct {
        // Description - User-friendly description of an AccountQuotaPolicy.
        Description *string `json:"description,omitempty"`
        // Quotas - A list of quota policy per instance type series.
        Quotas *[]InstanceTypeSeriesQuota `json:"quotas,omitempty"`
        }

        // AccountQuotaPolicyProperties describes properties of AccountQuotaPolicy resource.
        type AccountQuotaPolicyProperties struct {
        // ProvisioningState - Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled', 'ProvisioningStateCreating', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting'
        ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
        // Status - Possible values include: 'PolicyStatusCreating', 'PolicyStatusCreated', 'PolicyStatusUpdating', 'PolicyStatusDeleting', 'PolicyStatusFailed'
        Status PolicyStatus `json:"status,omitempty"`
        // Description - User-friendly description of an AccountQuotaPolicy.
        Description *string `json:"description,omitempty"`
        // Quotas - A list of quota policy per instance type series.
        Quotas *[]InstanceTypeSeriesQuota `json:"quotas,omitempty"`
        }

        // AccountQuotaPolicyResourceDescription describes an account quota policy resource in Singularity.
        type AccountQuotaPolicyResourceDescription struct {
        autorest.Response `json:"-"`
        *AccountQuotaPolicyResourceDescriptionProperties `json:"properties,omitempty"`
        // ID - READ-ONLY; Fully qualified identifier for the resource. For example, '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}'
        ID *string `json:"id,omitempty"`
        // Name - READ-ONLY; The name of the resource
        Name *string `json:"name,omitempty"`
        // Type - READ-ONLY; The type of the resource. For example, 'Microsoft.Compute/virtualMachines' or 'Microsoft.Storage/storageAccounts'.
        Type *string `json:"type,omitempty"`
        SystemData *ResourceSystemData `json:"systemData,omitempty"`
        }

        // MarshalJSON is the custom marshaler for AccountQuotaPolicyResourceDescription.
        func (aqprd AccountQuotaPolicyResourceDescription)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(aqprd.AccountQuotaPolicyResourceDescriptionProperties != nil) {
                objectMap["properties"] = aqprd.AccountQuotaPolicyResourceDescriptionProperties
                }
                if(aqprd.SystemData != nil) {
                objectMap["systemData"] = aqprd.SystemData
                }
                return json.Marshal(objectMap)
        }
        // UnmarshalJSON is the custom unmarshaler for AccountQuotaPolicyResourceDescription struct.
        func (aqprd *AccountQuotaPolicyResourceDescription) UnmarshalJSON(body []byte) error {
        var m map[string]*json.RawMessage
        err := json.Unmarshal(body, &m)
        if err != nil {
        return err
        }
        for k, v := range  m {
        switch k {
                case "properties":
    if v != nil {
        var accountQuotaPolicyResourceDescriptionProperties AccountQuotaPolicyResourceDescriptionProperties
        err = json.Unmarshal(*v, &accountQuotaPolicyResourceDescriptionProperties)
        if err != nil {
    return err
    }
        aqprd.AccountQuotaPolicyResourceDescriptionProperties = &accountQuotaPolicyResourceDescriptionProperties
    }
                case "id":
    if v != nil {
        var ID string
        err = json.Unmarshal(*v, &ID)
        if err != nil {
    return err
    }
        aqprd.ID = &ID
    }
                case "name":
    if v != nil {
        var name string
        err = json.Unmarshal(*v, &name)
        if err != nil {
    return err
    }
        aqprd.Name = &name
    }
                case "type":
    if v != nil {
        var typeVar string
        err = json.Unmarshal(*v, &typeVar)
        if err != nil {
    return err
    }
        aqprd.Type = &typeVar
    }
                case "systemData":
    if v != nil {
        var systemData ResourceSystemData
        err = json.Unmarshal(*v, &systemData)
        if err != nil {
    return err
    }
        aqprd.SystemData = &systemData
    }
            }
        }

        return nil
        }

        // AccountQuotaPolicyResourceDescriptionList a pageable list of AccountQuotaPolicy resources.
        type AccountQuotaPolicyResourceDescriptionList struct {
        autorest.Response `json:"-"`
        // Value - READ-ONLY; One page of the list.
        Value *[]AccountQuotaPolicyResourceDescription `json:"value,omitempty"`
        // NextLink - READ-ONLY; URI to fetch the next page of the list.
        NextLink *string `json:"nextLink,omitempty"`
        }

        // AccountQuotaPolicyResourceDescriptionListIterator provides access to a complete listing of
        // AccountQuotaPolicyResourceDescription values.
        type AccountQuotaPolicyResourceDescriptionListIterator struct {
            i int
            page AccountQuotaPolicyResourceDescriptionListPage
        }
        // NextWithContext advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        func (iter * AccountQuotaPolicyResourceDescriptionListIterator) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/AccountQuotaPolicyResourceDescriptionListIterator.NextWithContext")
        defer func() {
        sc := -1
        if iter.Response().Response.Response != nil {
        sc = iter.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        iter.i++
        if iter.i < len(iter. page.Values()) {
        return nil
        }
        err = iter.page.NextWithContext(ctx)
        if err != nil {
        iter. i--
        return err
        }
        iter.i = 0
        return nil
        }
        // Next advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (iter * AccountQuotaPolicyResourceDescriptionListIterator) Next() error {
        return iter.NextWithContext(context.Background())
        }
        // NotDone returns true if the enumeration should be started or is not yet complete.
        func (iter AccountQuotaPolicyResourceDescriptionListIterator) NotDone() bool {
        return iter.page.NotDone() && iter.i < len(iter. page.Values())
        }
        // Response returns the raw server response from the last page request.
        func (iter AccountQuotaPolicyResourceDescriptionListIterator) Response() AccountQuotaPolicyResourceDescriptionList {
        return iter.page.Response()
        }
        // Value returns the current value or a zero-initialized value if the
        // iterator has advanced beyond the end of the collection.
        func (iter AccountQuotaPolicyResourceDescriptionListIterator) Value() AccountQuotaPolicyResourceDescription {
        if !iter.page.NotDone() {
        return AccountQuotaPolicyResourceDescription{}
        }
        return iter.page.Values()[iter.i]
        }
        // Creates a new instance of the AccountQuotaPolicyResourceDescriptionListIterator type.
        func NewAccountQuotaPolicyResourceDescriptionListIterator (page AccountQuotaPolicyResourceDescriptionListPage) AccountQuotaPolicyResourceDescriptionListIterator {
            return AccountQuotaPolicyResourceDescriptionListIterator{page: page}
        }


            // IsEmpty returns true if the ListResult contains no values.
            func (aqprdl AccountQuotaPolicyResourceDescriptionList) IsEmpty() bool {
            return aqprdl.Value == nil || len(*aqprdl.Value) == 0
            }

            // hasNextLink returns true if the NextLink is not empty.
            func (aqprdl AccountQuotaPolicyResourceDescriptionList) hasNextLink() bool {
            return aqprdl.NextLink != nil && len(*aqprdl.NextLink) != 0
            }
                // accountQuotaPolicyResourceDescriptionListPreparer prepares a request to retrieve the next set of results.
                // It returns nil if no more results exist.
                func (aqprdl AccountQuotaPolicyResourceDescriptionList) accountQuotaPolicyResourceDescriptionListPreparer(ctx context.Context) (*http.Request, error) {
                if !aqprdl.hasNextLink() {
                return nil, nil
                }
                return autorest.Prepare((&http.Request{}).WithContext(ctx),
                autorest.AsJSON(),
                autorest.AsGet(),
                autorest.WithBaseURL(to.String( aqprdl.NextLink)));
                }

        // AccountQuotaPolicyResourceDescriptionListPage contains a page of AccountQuotaPolicyResourceDescription
        // values.
        type AccountQuotaPolicyResourceDescriptionListPage struct {
            fn func(context.Context, AccountQuotaPolicyResourceDescriptionList) (AccountQuotaPolicyResourceDescriptionList, error)
            aqprdl AccountQuotaPolicyResourceDescriptionList
        }

        // NextWithContext advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        func (page * AccountQuotaPolicyResourceDescriptionListPage) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/AccountQuotaPolicyResourceDescriptionListPage.NextWithContext")
        defer func() {
        sc := -1
        if page.Response().Response.Response != nil {
        sc = page.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        for {
            next, err := page.fn(ctx, page.aqprdl)
            if err != nil {
            return err
            }
            page.aqprdl = next
            if !next.hasNextLink() || !next.IsEmpty() {
                break
            }
        }
        return nil
        }

        // Next advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (page * AccountQuotaPolicyResourceDescriptionListPage) Next() error {
        return page.NextWithContext(context.Background())
        }
        // NotDone returns true if the page enumeration should be started or is not yet complete.
        func (page AccountQuotaPolicyResourceDescriptionListPage) NotDone() bool {
        return !page.aqprdl.IsEmpty()
        }
        // Response returns the raw server response from the last page request.
        func (page AccountQuotaPolicyResourceDescriptionListPage) Response() AccountQuotaPolicyResourceDescriptionList {
        return page.aqprdl
        }
        // Values returns the slice of values for the current page or nil if there are no values.
        func (page AccountQuotaPolicyResourceDescriptionListPage) Values() []AccountQuotaPolicyResourceDescription {
        if page.aqprdl.IsEmpty() {
        return nil
        }
        return *page.aqprdl.Value
        }
        // Creates a new instance of the AccountQuotaPolicyResourceDescriptionListPage type.
        func NewAccountQuotaPolicyResourceDescriptionListPage (getNextPage func(context.Context, AccountQuotaPolicyResourceDescriptionList) (AccountQuotaPolicyResourceDescriptionList, error)) AccountQuotaPolicyResourceDescriptionListPage {
            return AccountQuotaPolicyResourceDescriptionListPage{fn: getNextPage}
        }

        // AccountQuotaPolicyResourceDescriptionProperties ...
        type AccountQuotaPolicyResourceDescriptionProperties struct {
        // ProvisioningState - Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled', 'ProvisioningStateCreating', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting'
        ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
        // Status - Possible values include: 'PolicyStatusCreating', 'PolicyStatusCreated', 'PolicyStatusUpdating', 'PolicyStatusDeleting', 'PolicyStatusFailed'
        Status PolicyStatus `json:"status,omitempty"`
        // Description - User-friendly description of an AccountQuotaPolicy.
        Description *string `json:"description,omitempty"`
        // Quotas - A list of quota policy per instance type series.
        Quotas *[]InstanceTypeSeriesQuota `json:"quotas,omitempty"`
        }

        // AccountQuotaPolicyResourcePatchDescription describes all properties which can be updated for a Singularity
        // account quota policy resource.
        type AccountQuotaPolicyResourcePatchDescription struct {
        *AccountQuotaPolicyResourcePatchDescriptionProperties `json:"properties,omitempty"`
        // ID - READ-ONLY; Fully qualified identifier for the resource. For example, '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}'
        ID *string `json:"id,omitempty"`
        // Name - READ-ONLY; The name of the resource
        Name *string `json:"name,omitempty"`
        // Type - READ-ONLY; The type of the resource. For example, 'Microsoft.Compute/virtualMachines' or 'Microsoft.Storage/storageAccounts'.
        Type *string `json:"type,omitempty"`
        SystemData *ResourceSystemData `json:"systemData,omitempty"`
        }

        // MarshalJSON is the custom marshaler for AccountQuotaPolicyResourcePatchDescription.
        func (aqprpd AccountQuotaPolicyResourcePatchDescription)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(aqprpd.AccountQuotaPolicyResourcePatchDescriptionProperties != nil) {
                objectMap["properties"] = aqprpd.AccountQuotaPolicyResourcePatchDescriptionProperties
                }
                if(aqprpd.SystemData != nil) {
                objectMap["systemData"] = aqprpd.SystemData
                }
                return json.Marshal(objectMap)
        }
        // UnmarshalJSON is the custom unmarshaler for AccountQuotaPolicyResourcePatchDescription struct.
        func (aqprpd *AccountQuotaPolicyResourcePatchDescription) UnmarshalJSON(body []byte) error {
        var m map[string]*json.RawMessage
        err := json.Unmarshal(body, &m)
        if err != nil {
        return err
        }
        for k, v := range  m {
        switch k {
                case "properties":
    if v != nil {
        var accountQuotaPolicyResourcePatchDescriptionProperties AccountQuotaPolicyResourcePatchDescriptionProperties
        err = json.Unmarshal(*v, &accountQuotaPolicyResourcePatchDescriptionProperties)
        if err != nil {
    return err
    }
        aqprpd.AccountQuotaPolicyResourcePatchDescriptionProperties = &accountQuotaPolicyResourcePatchDescriptionProperties
    }
                case "id":
    if v != nil {
        var ID string
        err = json.Unmarshal(*v, &ID)
        if err != nil {
    return err
    }
        aqprpd.ID = &ID
    }
                case "name":
    if v != nil {
        var name string
        err = json.Unmarshal(*v, &name)
        if err != nil {
    return err
    }
        aqprpd.Name = &name
    }
                case "type":
    if v != nil {
        var typeVar string
        err = json.Unmarshal(*v, &typeVar)
        if err != nil {
    return err
    }
        aqprpd.Type = &typeVar
    }
                case "systemData":
    if v != nil {
        var systemData ResourceSystemData
        err = json.Unmarshal(*v, &systemData)
        if err != nil {
    return err
    }
        aqprpd.SystemData = &systemData
    }
            }
        }

        return nil
        }

        // AccountQuotaPolicyResourcePatchDescriptionProperties ...
        type AccountQuotaPolicyResourcePatchDescriptionProperties struct {
        // Description - User-friendly description of an AccountQuotaPolicy.
        Description *string `json:"description,omitempty"`
        // Quotas - A list of quota policy per instance type series.
        Quotas *[]InstanceTypeSeriesQuota `json:"quotas,omitempty"`
        }

        // AccountQuotaPolicyUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
        // operation.
        type AccountQuotaPolicyUpdateFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *AccountQuotaPolicyUpdateFuture) Result(client AccountQuotaPolicyClient) (aqprd AccountQuotaPolicyResourceDescription, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.AccountQuotaPolicyUpdateFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("microsoftazuremanagementaisupercomputer.AccountQuotaPolicyUpdateFuture")
        return
        }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if aqprd.Response.Response, err = future.GetResult(sender); err == nil && aqprd.Response.Response.StatusCode != http.StatusNoContent {
            aqprd, err = client.UpdateResponder(aqprd.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.AccountQuotaPolicyUpdateFuture", "Result", aqprd.Response.Response, "Failure responding to request")
            }
            }
            return
        }

        // AccountResourceDescription describes an account resource in Singularity.
        type AccountResourceDescription struct {
        autorest.Response `json:"-"`
        *AccountResourceDescriptionProperties `json:"properties,omitempty"`
        // Location - The geo-location where the resource lives.
        Location *string `json:"location,omitempty"`
        // Tags - Resource tags.
        Tags map[string]*string `json:"tags"`
        // ID - READ-ONLY; Fully qualified identifier for the resource. For example, '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}'
        ID *string `json:"id,omitempty"`
        // Name - READ-ONLY; The name of the resource
        Name *string `json:"name,omitempty"`
        // Type - READ-ONLY; The type of the resource. For example, 'Microsoft.Compute/virtualMachines' or 'Microsoft.Storage/storageAccounts'.
        Type *string `json:"type,omitempty"`
        SystemData *ResourceSystemData `json:"systemData,omitempty"`
        }

        // MarshalJSON is the custom marshaler for AccountResourceDescription.
        func (ard AccountResourceDescription)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(ard.AccountResourceDescriptionProperties != nil) {
                objectMap["properties"] = ard.AccountResourceDescriptionProperties
                }
                if(ard.Location != nil) {
                objectMap["location"] = ard.Location
                }
                if(ard.Tags != nil) {
                objectMap["tags"] = ard.Tags
                }
                if(ard.SystemData != nil) {
                objectMap["systemData"] = ard.SystemData
                }
                return json.Marshal(objectMap)
        }
        // UnmarshalJSON is the custom unmarshaler for AccountResourceDescription struct.
        func (ard *AccountResourceDescription) UnmarshalJSON(body []byte) error {
        var m map[string]*json.RawMessage
        err := json.Unmarshal(body, &m)
        if err != nil {
        return err
        }
        for k, v := range  m {
        switch k {
                case "properties":
    if v != nil {
        var accountResourceDescriptionProperties AccountResourceDescriptionProperties
        err = json.Unmarshal(*v, &accountResourceDescriptionProperties)
        if err != nil {
    return err
    }
        ard.AccountResourceDescriptionProperties = &accountResourceDescriptionProperties
    }
                case "location":
    if v != nil {
        var location string
        err = json.Unmarshal(*v, &location)
        if err != nil {
    return err
    }
        ard.Location = &location
    }
                case "tags":
    if v != nil {
        var tags map[string]*string
        err = json.Unmarshal(*v, &tags)
        if err != nil {
    return err
    }
        ard.Tags = tags
    }
                case "id":
    if v != nil {
        var ID string
        err = json.Unmarshal(*v, &ID)
        if err != nil {
    return err
    }
        ard.ID = &ID
    }
                case "name":
    if v != nil {
        var name string
        err = json.Unmarshal(*v, &name)
        if err != nil {
    return err
    }
        ard.Name = &name
    }
                case "type":
    if v != nil {
        var typeVar string
        err = json.Unmarshal(*v, &typeVar)
        if err != nil {
    return err
    }
        ard.Type = &typeVar
    }
                case "systemData":
    if v != nil {
        var systemData ResourceSystemData
        err = json.Unmarshal(*v, &systemData)
        if err != nil {
    return err
    }
        ard.SystemData = &systemData
    }
            }
        }

        return nil
        }

        // AccountResourceDescriptionList a pageable list of Account resources.
        type AccountResourceDescriptionList struct {
        autorest.Response `json:"-"`
        // Value - READ-ONLY; One page of the list.
        Value *[]AccountResourceDescription `json:"value,omitempty"`
        // NextLink - READ-ONLY; URI to fetch the next page of the list.
        NextLink *string `json:"nextLink,omitempty"`
        }

        // AccountResourceDescriptionListIterator provides access to a complete listing of AccountResourceDescription
        // values.
        type AccountResourceDescriptionListIterator struct {
            i int
            page AccountResourceDescriptionListPage
        }
        // NextWithContext advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        func (iter * AccountResourceDescriptionListIterator) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/AccountResourceDescriptionListIterator.NextWithContext")
        defer func() {
        sc := -1
        if iter.Response().Response.Response != nil {
        sc = iter.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        iter.i++
        if iter.i < len(iter. page.Values()) {
        return nil
        }
        err = iter.page.NextWithContext(ctx)
        if err != nil {
        iter. i--
        return err
        }
        iter.i = 0
        return nil
        }
        // Next advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (iter * AccountResourceDescriptionListIterator) Next() error {
        return iter.NextWithContext(context.Background())
        }
        // NotDone returns true if the enumeration should be started or is not yet complete.
        func (iter AccountResourceDescriptionListIterator) NotDone() bool {
        return iter.page.NotDone() && iter.i < len(iter. page.Values())
        }
        // Response returns the raw server response from the last page request.
        func (iter AccountResourceDescriptionListIterator) Response() AccountResourceDescriptionList {
        return iter.page.Response()
        }
        // Value returns the current value or a zero-initialized value if the
        // iterator has advanced beyond the end of the collection.
        func (iter AccountResourceDescriptionListIterator) Value() AccountResourceDescription {
        if !iter.page.NotDone() {
        return AccountResourceDescription{}
        }
        return iter.page.Values()[iter.i]
        }
        // Creates a new instance of the AccountResourceDescriptionListIterator type.
        func NewAccountResourceDescriptionListIterator (page AccountResourceDescriptionListPage) AccountResourceDescriptionListIterator {
            return AccountResourceDescriptionListIterator{page: page}
        }


            // IsEmpty returns true if the ListResult contains no values.
            func (ardl AccountResourceDescriptionList) IsEmpty() bool {
            return ardl.Value == nil || len(*ardl.Value) == 0
            }

            // hasNextLink returns true if the NextLink is not empty.
            func (ardl AccountResourceDescriptionList) hasNextLink() bool {
            return ardl.NextLink != nil && len(*ardl.NextLink) != 0
            }
                // accountResourceDescriptionListPreparer prepares a request to retrieve the next set of results.
                // It returns nil if no more results exist.
                func (ardl AccountResourceDescriptionList) accountResourceDescriptionListPreparer(ctx context.Context) (*http.Request, error) {
                if !ardl.hasNextLink() {
                return nil, nil
                }
                return autorest.Prepare((&http.Request{}).WithContext(ctx),
                autorest.AsJSON(),
                autorest.AsGet(),
                autorest.WithBaseURL(to.String( ardl.NextLink)));
                }

        // AccountResourceDescriptionListPage contains a page of AccountResourceDescription values.
        type AccountResourceDescriptionListPage struct {
            fn func(context.Context, AccountResourceDescriptionList) (AccountResourceDescriptionList, error)
            ardl AccountResourceDescriptionList
        }

        // NextWithContext advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        func (page * AccountResourceDescriptionListPage) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/AccountResourceDescriptionListPage.NextWithContext")
        defer func() {
        sc := -1
        if page.Response().Response.Response != nil {
        sc = page.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        for {
            next, err := page.fn(ctx, page.ardl)
            if err != nil {
            return err
            }
            page.ardl = next
            if !next.hasNextLink() || !next.IsEmpty() {
                break
            }
        }
        return nil
        }

        // Next advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (page * AccountResourceDescriptionListPage) Next() error {
        return page.NextWithContext(context.Background())
        }
        // NotDone returns true if the page enumeration should be started or is not yet complete.
        func (page AccountResourceDescriptionListPage) NotDone() bool {
        return !page.ardl.IsEmpty()
        }
        // Response returns the raw server response from the last page request.
        func (page AccountResourceDescriptionListPage) Response() AccountResourceDescriptionList {
        return page.ardl
        }
        // Values returns the slice of values for the current page or nil if there are no values.
        func (page AccountResourceDescriptionListPage) Values() []AccountResourceDescription {
        if page.ardl.IsEmpty() {
        return nil
        }
        return *page.ardl.Value
        }
        // Creates a new instance of the AccountResourceDescriptionListPage type.
        func NewAccountResourceDescriptionListPage (getNextPage func(context.Context, AccountResourceDescriptionList) (AccountResourceDescriptionList, error)) AccountResourceDescriptionListPage {
            return AccountResourceDescriptionListPage{fn: getNextPage}
        }

        // AccountResourceDescriptionProperties ...
        type AccountResourceDescriptionProperties struct {
        // ProvisioningState - Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled', 'ProvisioningStateCreating', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting'
        ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
        // Description - User-friendly description of an account.
        Description *string `json:"description,omitempty"`
        // Status - Possible values include: 'Creating', 'Created', 'Updating', 'Deleting', 'Failed'
        Status AccountStatus `json:"status,omitempty"`
        SchedulingPolicy *SchedulingPolicy `json:"schedulingPolicy,omitempty"`
        IdleResourcesHandlingPolicy *IdleResourcesHandlingPolicy `json:"idleResourcesHandlingPolicy,omitempty"`
        // StatusDetails - READ-ONLY; Gives additional information about the current status of an account.
        StatusDetails *string `json:"statusDetails,omitempty"`
        // Locations - The collection of account locations.
        Locations *[]AccountLocation `json:"locations,omitempty"`
        NetworkSettings *NetworkSettings `json:"networkSettings,omitempty"`
        }

        // MarshalJSON is the custom marshaler for AccountResourceDescriptionProperties.
        func (ard AccountResourceDescriptionProperties)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(ard.ProvisioningState != "") {
                objectMap["provisioningState"] = ard.ProvisioningState
                }
                if(ard.Description != nil) {
                objectMap["description"] = ard.Description
                }
                if(ard.Status != "") {
                objectMap["status"] = ard.Status
                }
                if(ard.SchedulingPolicy != nil) {
                objectMap["schedulingPolicy"] = ard.SchedulingPolicy
                }
                if(ard.IdleResourcesHandlingPolicy != nil) {
                objectMap["idleResourcesHandlingPolicy"] = ard.IdleResourcesHandlingPolicy
                }
                if(ard.Locations != nil) {
                objectMap["locations"] = ard.Locations
                }
                if(ard.NetworkSettings != nil) {
                objectMap["networkSettings"] = ard.NetworkSettings
                }
                return json.Marshal(objectMap)
        }

        // AccountResourcePatchDescription describes all properties which can be updated for a Singularity account
        // resource.
        type AccountResourcePatchDescription struct {
        *AccountResourcePatchDescriptionProperties `json:"properties,omitempty"`
        // ID - READ-ONLY; Fully qualified identifier for the resource. For example, '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}'
        ID *string `json:"id,omitempty"`
        // Name - READ-ONLY; The name of the resource
        Name *string `json:"name,omitempty"`
        // Type - READ-ONLY; The type of the resource. For example, 'Microsoft.Compute/virtualMachines' or 'Microsoft.Storage/storageAccounts'.
        Type *string `json:"type,omitempty"`
        SystemData *ResourceSystemData `json:"systemData,omitempty"`
        }

        // MarshalJSON is the custom marshaler for AccountResourcePatchDescription.
        func (arpd AccountResourcePatchDescription)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(arpd.AccountResourcePatchDescriptionProperties != nil) {
                objectMap["properties"] = arpd.AccountResourcePatchDescriptionProperties
                }
                if(arpd.SystemData != nil) {
                objectMap["systemData"] = arpd.SystemData
                }
                return json.Marshal(objectMap)
        }
        // UnmarshalJSON is the custom unmarshaler for AccountResourcePatchDescription struct.
        func (arpd *AccountResourcePatchDescription) UnmarshalJSON(body []byte) error {
        var m map[string]*json.RawMessage
        err := json.Unmarshal(body, &m)
        if err != nil {
        return err
        }
        for k, v := range  m {
        switch k {
                case "properties":
    if v != nil {
        var accountResourcePatchDescriptionProperties AccountResourcePatchDescriptionProperties
        err = json.Unmarshal(*v, &accountResourcePatchDescriptionProperties)
        if err != nil {
    return err
    }
        arpd.AccountResourcePatchDescriptionProperties = &accountResourcePatchDescriptionProperties
    }
                case "id":
    if v != nil {
        var ID string
        err = json.Unmarshal(*v, &ID)
        if err != nil {
    return err
    }
        arpd.ID = &ID
    }
                case "name":
    if v != nil {
        var name string
        err = json.Unmarshal(*v, &name)
        if err != nil {
    return err
    }
        arpd.Name = &name
    }
                case "type":
    if v != nil {
        var typeVar string
        err = json.Unmarshal(*v, &typeVar)
        if err != nil {
    return err
    }
        arpd.Type = &typeVar
    }
                case "systemData":
    if v != nil {
        var systemData ResourceSystemData
        err = json.Unmarshal(*v, &systemData)
        if err != nil {
    return err
    }
        arpd.SystemData = &systemData
    }
            }
        }

        return nil
        }

        // AccountResourcePatchDescriptionProperties ...
        type AccountResourcePatchDescriptionProperties struct {
        // Description - User-friendly description of an account.
        Description *string `json:"description,omitempty"`
        SchedulingPolicy *SchedulingPolicy `json:"schedulingPolicy,omitempty"`
        IdleResourcesHandlingPolicy *IdleResourcesHandlingPolicy `json:"idleResourcesHandlingPolicy,omitempty"`
        // Locations - The collection of account locations.
        Locations *[]AccountLocation `json:"locations,omitempty"`
        NetworkSettings *NetworkSettings `json:"networkSettings,omitempty"`
        }

        // AccountUpdateFuture an abstraction for monitoring and retrieving the results of a long-running operation.
        type AccountUpdateFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *AccountUpdateFuture) Result(client AccountClient) (ard AccountResourceDescription, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.AccountUpdateFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("microsoftazuremanagementaisupercomputer.AccountUpdateFuture")
        return
        }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if ard.Response.Response, err = future.GetResult(sender); err == nil && ard.Response.Response.StatusCode != http.StatusNoContent {
            ard, err = client.UpdateResponder(ard.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.AccountUpdateFuture", "Result", ard.Response.Response, "Failure responding to request")
            }
            }
            return
        }

        // AvailableInstanceTypeDescription instance type available in the location.
        type AvailableInstanceTypeDescription struct {
        // Name - READ-ONLY; Name for the instance type.
        Name *string `json:"name,omitempty"`
        }

        // AvailableInstanceTypeDescriptionList a pageable list of available instance types.
        type AvailableInstanceTypeDescriptionList struct {
        autorest.Response `json:"-"`
        // Value - READ-ONLY; One page of the list.
        Value *[]AvailableInstanceTypeDescription `json:"value,omitempty"`
        // NextLink - READ-ONLY; URI to fetch the next page of the list.
        NextLink *string `json:"nextLink,omitempty"`
        }

        // AvailableInstanceTypeDescriptionListIterator provides access to a complete listing of
        // AvailableInstanceTypeDescription values.
        type AvailableInstanceTypeDescriptionListIterator struct {
            i int
            page AvailableInstanceTypeDescriptionListPage
        }
        // NextWithContext advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        func (iter * AvailableInstanceTypeDescriptionListIterator) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/AvailableInstanceTypeDescriptionListIterator.NextWithContext")
        defer func() {
        sc := -1
        if iter.Response().Response.Response != nil {
        sc = iter.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        iter.i++
        if iter.i < len(iter. page.Values()) {
        return nil
        }
        err = iter.page.NextWithContext(ctx)
        if err != nil {
        iter. i--
        return err
        }
        iter.i = 0
        return nil
        }
        // Next advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (iter * AvailableInstanceTypeDescriptionListIterator) Next() error {
        return iter.NextWithContext(context.Background())
        }
        // NotDone returns true if the enumeration should be started or is not yet complete.
        func (iter AvailableInstanceTypeDescriptionListIterator) NotDone() bool {
        return iter.page.NotDone() && iter.i < len(iter. page.Values())
        }
        // Response returns the raw server response from the last page request.
        func (iter AvailableInstanceTypeDescriptionListIterator) Response() AvailableInstanceTypeDescriptionList {
        return iter.page.Response()
        }
        // Value returns the current value or a zero-initialized value if the
        // iterator has advanced beyond the end of the collection.
        func (iter AvailableInstanceTypeDescriptionListIterator) Value() AvailableInstanceTypeDescription {
        if !iter.page.NotDone() {
        return AvailableInstanceTypeDescription{}
        }
        return iter.page.Values()[iter.i]
        }
        // Creates a new instance of the AvailableInstanceTypeDescriptionListIterator type.
        func NewAvailableInstanceTypeDescriptionListIterator (page AvailableInstanceTypeDescriptionListPage) AvailableInstanceTypeDescriptionListIterator {
            return AvailableInstanceTypeDescriptionListIterator{page: page}
        }


            // IsEmpty returns true if the ListResult contains no values.
            func (aitdl AvailableInstanceTypeDescriptionList) IsEmpty() bool {
            return aitdl.Value == nil || len(*aitdl.Value) == 0
            }

            // hasNextLink returns true if the NextLink is not empty.
            func (aitdl AvailableInstanceTypeDescriptionList) hasNextLink() bool {
            return aitdl.NextLink != nil && len(*aitdl.NextLink) != 0
            }
                // availableInstanceTypeDescriptionListPreparer prepares a request to retrieve the next set of results.
                // It returns nil if no more results exist.
                func (aitdl AvailableInstanceTypeDescriptionList) availableInstanceTypeDescriptionListPreparer(ctx context.Context) (*http.Request, error) {
                if !aitdl.hasNextLink() {
                return nil, nil
                }
                return autorest.Prepare((&http.Request{}).WithContext(ctx),
                autorest.AsJSON(),
                autorest.AsGet(),
                autorest.WithBaseURL(to.String( aitdl.NextLink)));
                }

        // AvailableInstanceTypeDescriptionListPage contains a page of AvailableInstanceTypeDescription values.
        type AvailableInstanceTypeDescriptionListPage struct {
            fn func(context.Context, AvailableInstanceTypeDescriptionList) (AvailableInstanceTypeDescriptionList, error)
            aitdl AvailableInstanceTypeDescriptionList
        }

        // NextWithContext advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        func (page * AvailableInstanceTypeDescriptionListPage) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/AvailableInstanceTypeDescriptionListPage.NextWithContext")
        defer func() {
        sc := -1
        if page.Response().Response.Response != nil {
        sc = page.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        for {
            next, err := page.fn(ctx, page.aitdl)
            if err != nil {
            return err
            }
            page.aitdl = next
            if !next.hasNextLink() || !next.IsEmpty() {
                break
            }
        }
        return nil
        }

        // Next advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (page * AvailableInstanceTypeDescriptionListPage) Next() error {
        return page.NextWithContext(context.Background())
        }
        // NotDone returns true if the page enumeration should be started or is not yet complete.
        func (page AvailableInstanceTypeDescriptionListPage) NotDone() bool {
        return !page.aitdl.IsEmpty()
        }
        // Response returns the raw server response from the last page request.
        func (page AvailableInstanceTypeDescriptionListPage) Response() AvailableInstanceTypeDescriptionList {
        return page.aitdl
        }
        // Values returns the slice of values for the current page or nil if there are no values.
        func (page AvailableInstanceTypeDescriptionListPage) Values() []AvailableInstanceTypeDescription {
        if page.aitdl.IsEmpty() {
        return nil
        }
        return *page.aitdl.Value
        }
        // Creates a new instance of the AvailableInstanceTypeDescriptionListPage type.
        func NewAvailableInstanceTypeDescriptionListPage (getNextPage func(context.Context, AvailableInstanceTypeDescriptionList) (AvailableInstanceTypeDescriptionList, error)) AvailableInstanceTypeDescriptionListPage {
            return AvailableInstanceTypeDescriptionListPage{fn: getNextPage}
        }

        // AvailableInstanceTypeSeriesDescription instance type series available in the location.
        type AvailableInstanceTypeSeriesDescription struct {
        // ID - READ-ONLY; Unique identifier for the instance type series.
        ID *string `json:"id,omitempty"`
        // Name - READ-ONLY; Descriptive name for the instance type series.
        Name *string `json:"name,omitempty"`
        }

        // AvailableInstanceTypeSeriesDescriptionList a pageable list of available instance type series.
        type AvailableInstanceTypeSeriesDescriptionList struct {
        autorest.Response `json:"-"`
        // Value - READ-ONLY; One page of the list.
        Value *[]AvailableInstanceTypeSeriesDescription `json:"value,omitempty"`
        // NextLink - READ-ONLY; URI to fetch the next page of the list.
        NextLink *string `json:"nextLink,omitempty"`
        }

        // AvailableInstanceTypeSeriesDescriptionListIterator provides access to a complete listing of
        // AvailableInstanceTypeSeriesDescription values.
        type AvailableInstanceTypeSeriesDescriptionListIterator struct {
            i int
            page AvailableInstanceTypeSeriesDescriptionListPage
        }
        // NextWithContext advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        func (iter * AvailableInstanceTypeSeriesDescriptionListIterator) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/AvailableInstanceTypeSeriesDescriptionListIterator.NextWithContext")
        defer func() {
        sc := -1
        if iter.Response().Response.Response != nil {
        sc = iter.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        iter.i++
        if iter.i < len(iter. page.Values()) {
        return nil
        }
        err = iter.page.NextWithContext(ctx)
        if err != nil {
        iter. i--
        return err
        }
        iter.i = 0
        return nil
        }
        // Next advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (iter * AvailableInstanceTypeSeriesDescriptionListIterator) Next() error {
        return iter.NextWithContext(context.Background())
        }
        // NotDone returns true if the enumeration should be started or is not yet complete.
        func (iter AvailableInstanceTypeSeriesDescriptionListIterator) NotDone() bool {
        return iter.page.NotDone() && iter.i < len(iter. page.Values())
        }
        // Response returns the raw server response from the last page request.
        func (iter AvailableInstanceTypeSeriesDescriptionListIterator) Response() AvailableInstanceTypeSeriesDescriptionList {
        return iter.page.Response()
        }
        // Value returns the current value or a zero-initialized value if the
        // iterator has advanced beyond the end of the collection.
        func (iter AvailableInstanceTypeSeriesDescriptionListIterator) Value() AvailableInstanceTypeSeriesDescription {
        if !iter.page.NotDone() {
        return AvailableInstanceTypeSeriesDescription{}
        }
        return iter.page.Values()[iter.i]
        }
        // Creates a new instance of the AvailableInstanceTypeSeriesDescriptionListIterator type.
        func NewAvailableInstanceTypeSeriesDescriptionListIterator (page AvailableInstanceTypeSeriesDescriptionListPage) AvailableInstanceTypeSeriesDescriptionListIterator {
            return AvailableInstanceTypeSeriesDescriptionListIterator{page: page}
        }


            // IsEmpty returns true if the ListResult contains no values.
            func (aitsdl AvailableInstanceTypeSeriesDescriptionList) IsEmpty() bool {
            return aitsdl.Value == nil || len(*aitsdl.Value) == 0
            }

            // hasNextLink returns true if the NextLink is not empty.
            func (aitsdl AvailableInstanceTypeSeriesDescriptionList) hasNextLink() bool {
            return aitsdl.NextLink != nil && len(*aitsdl.NextLink) != 0
            }
                // availableInstanceTypeSeriesDescriptionListPreparer prepares a request to retrieve the next set of results.
                // It returns nil if no more results exist.
                func (aitsdl AvailableInstanceTypeSeriesDescriptionList) availableInstanceTypeSeriesDescriptionListPreparer(ctx context.Context) (*http.Request, error) {
                if !aitsdl.hasNextLink() {
                return nil, nil
                }
                return autorest.Prepare((&http.Request{}).WithContext(ctx),
                autorest.AsJSON(),
                autorest.AsGet(),
                autorest.WithBaseURL(to.String( aitsdl.NextLink)));
                }

        // AvailableInstanceTypeSeriesDescriptionListPage contains a page of AvailableInstanceTypeSeriesDescription
        // values.
        type AvailableInstanceTypeSeriesDescriptionListPage struct {
            fn func(context.Context, AvailableInstanceTypeSeriesDescriptionList) (AvailableInstanceTypeSeriesDescriptionList, error)
            aitsdl AvailableInstanceTypeSeriesDescriptionList
        }

        // NextWithContext advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        func (page * AvailableInstanceTypeSeriesDescriptionListPage) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/AvailableInstanceTypeSeriesDescriptionListPage.NextWithContext")
        defer func() {
        sc := -1
        if page.Response().Response.Response != nil {
        sc = page.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        for {
            next, err := page.fn(ctx, page.aitsdl)
            if err != nil {
            return err
            }
            page.aitsdl = next
            if !next.hasNextLink() || !next.IsEmpty() {
                break
            }
        }
        return nil
        }

        // Next advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (page * AvailableInstanceTypeSeriesDescriptionListPage) Next() error {
        return page.NextWithContext(context.Background())
        }
        // NotDone returns true if the page enumeration should be started or is not yet complete.
        func (page AvailableInstanceTypeSeriesDescriptionListPage) NotDone() bool {
        return !page.aitsdl.IsEmpty()
        }
        // Response returns the raw server response from the last page request.
        func (page AvailableInstanceTypeSeriesDescriptionListPage) Response() AvailableInstanceTypeSeriesDescriptionList {
        return page.aitsdl
        }
        // Values returns the slice of values for the current page or nil if there are no values.
        func (page AvailableInstanceTypeSeriesDescriptionListPage) Values() []AvailableInstanceTypeSeriesDescription {
        if page.aitsdl.IsEmpty() {
        return nil
        }
        return *page.aitsdl.Value
        }
        // Creates a new instance of the AvailableInstanceTypeSeriesDescriptionListPage type.
        func NewAvailableInstanceTypeSeriesDescriptionListPage (getNextPage func(context.Context, AvailableInstanceTypeSeriesDescriptionList) (AvailableInstanceTypeSeriesDescriptionList, error)) AvailableInstanceTypeSeriesDescriptionListPage {
            return AvailableInstanceTypeSeriesDescriptionListPage{fn: getNextPage}
        }

        // CheckpointPolicy describes the checkpointing policy for job
        type CheckpointPolicy struct {
        // EnableCheckpoint - Enables automatic checkpointing of training job.
        EnableCheckpoint *bool `json:"enableCheckpoint,omitempty"`
        // CheckpointRelativePath - The relative path in the platform storage.
        CheckpointRelativePath *string `json:"checkpointRelativePath,omitempty"`
        // CheckpointInterval - Maximum elapsed duration between subsequent checkpoints. The value should be in ISO  8601 format (http://en.wikipedia.org/wiki/ISO_8601#Durations).
        CheckpointInterval *string `json:"checkpointInterval,omitempty"`
        // CheckpointIterationCount - Maximum elapsed iteration count between the subsequent checkpoints.
        CheckpointIterationCount *int32 `json:"checkpointIterationCount,omitempty"`
        CheckpointRetentionPolicy *CheckpointRetentionPolicy `json:"checkpointRetentionPolicy,omitempty"`
        }

        // CheckpointRetentionPolicy describes the checkpointing retention policy for job
        type CheckpointRetentionPolicy struct {
        // Mode - Possible values include: 'TTL', 'MaxStorage'
        Mode CheckpointRetentionMode `json:"mode,omitempty"`
        // TTL - Minimum elapsed duration before deleting checkpoint. The value should be in ISO  8601 format (http://en.wikipedia.org/wiki/ISO_8601#Durations).
        TTL *string `json:"ttl,omitempty"`
        // MaxStorage - Maximum storage size for checkpoint files to retain. Checkpoint files will be purged in FIFO manner.
        MaxStorage *int32 `json:"maxStorage,omitempty"`
        }

        // CompilationPolicy describes the properties of compilation policy.
        type CompilationPolicy struct {
        // InputSpec - Input spec (json) to the compiler.
        InputSpec *string `json:"inputSpec,omitempty"`
        // OutputSpec - Output spec (json) from the compiler.
        OutputSpec *string `json:"outputSpec,omitempty"`
        // CompilationMode - Possible values include: 'OptmizedStatic', 'Static', 'Eager'
        CompilationMode CompilationMode `json:"compilationMode,omitempty"`
        // ParallelismStrategy - Possible values include: 'DistributedDataParallel', 'ModelParallel', 'PipelineParallel', 'ZeRODistributedDataParallel'
        ParallelismStrategy ParallelismStrategy `json:"parallelismStrategy,omitempty"`
        }

        // CustomImage describes a custom image for the job resource.
        type CustomImage struct {
        // ContainerImageLocation - Location of container image to use for the training.
        ContainerImageLocation *string `json:"containerImageLocation,omitempty"`
        // ContainerRegistryUsername - Location of container image to use for the training.
        ContainerRegistryUsername *string `json:"containerRegistryUsername,omitempty"`
        // ContainerRegistryPassword - Password of the container registry account.
        ContainerRegistryPassword *string `json:"containerRegistryPassword,omitempty"`
        }

        // DeploymentPolicy describes the properties of deployment policy.
        type DeploymentPolicy struct {
        // AutoDeploy - Enables automatic deployment of the model at the end of training for inferencing.
        AutoDeploy *bool `json:"autoDeploy,omitempty"`
        // ModelVersionLink - The system generated link to the version resource of the model, post-deployment.
        ModelVersionLink *string `json:"modelVersionLink,omitempty"`
        // ModelLink - The link to the model resource under which the version needs to be deployed.
        ModelLink *string `json:"modelLink,omitempty"`
        }

        // ErrorDetailsModel ...
        type ErrorDetailsModel struct {
        Code *string `json:"code,omitempty"`
        Message *string `json:"message,omitempty"`
        }

        // ErrorModel ...
        type ErrorModel struct {
        Error *ErrorModelProperties `json:"error,omitempty"`
        }

        // ErrorModelProperties ...
        type ErrorModelProperties struct {
        Code *string `json:"code,omitempty"`
        Message *string `json:"message,omitempty"`
        InnerError *string `json:"innerError,omitempty"`
        Details *[]ErrorDetailsModel `json:"details,omitempty"`
        }

// BasicFrameworkImageBase describes the framework for the job resource.
        type BasicFrameworkImageBase interface {
            AsTensorFlowFrameworkImage () (*TensorFlowFrameworkImage, bool)
            AsPyTorchFrameworkImage () (*PyTorchFrameworkImage, bool)
        AsFrameworkImageBase () (*FrameworkImageBase, bool)
        }

        // FrameworkImageBase describes the framework for the job resource.
        type FrameworkImageBase struct {
        CustomImage *CustomImage `json:"customImage,omitempty"`
        // Kind - Possible values include: 'KindFrameworkImageBase', 'KindTensorFlow', 'KindPyTorch'
        Kind KindBasicFrameworkImageBase `json:"kind,omitempty"`
        }

        func unmarshalBasicFrameworkImageBase(body []byte) (BasicFrameworkImageBase, error){
        var m map[string]interface{}
        err := json.Unmarshal(body, &m)
        if err != nil {
        return nil, err
        }

        switch m["kind"] {
            case string(KindTensorFlow):
            var tffi TensorFlowFrameworkImage
            err := json.Unmarshal(body, &tffi)
            return tffi, err
            case string(KindPyTorch):
            var ptfi PyTorchFrameworkImage
            err := json.Unmarshal(body, &ptfi)
            return ptfi, err
                    default:
        var fib FrameworkImageBase
        err := json.Unmarshal(body, &fib)
        return fib, err
        }
        }
        func unmarshalBasicFrameworkImageBaseArray(body []byte) ([]BasicFrameworkImageBase, error){
        var rawMessages []*json.RawMessage
        err := json.Unmarshal(body, &rawMessages)
        if err != nil {
        return nil, err
        }

        fibArray := make([]BasicFrameworkImageBase, len(rawMessages))

        for index, rawMessage := range rawMessages {
        fib, err := unmarshalBasicFrameworkImageBase(*rawMessage)
        if err != nil {
        return nil, err
        }
        fibArray[index] = fib
        }
        return fibArray, nil
        }

        // MarshalJSON is the custom marshaler for FrameworkImageBase.
        func (fib FrameworkImageBase)MarshalJSON() ([]byte, error){
            fib.Kind = KindFrameworkImageBase
            objectMap := make(map[string]interface{})
                if(fib.CustomImage != nil) {
                objectMap["customImage"] = fib.CustomImage
                }
                if(fib.Kind != "") {
                objectMap["kind"] = fib.Kind
                }
                return json.Marshal(objectMap)
        }

            // AsTensorFlowFrameworkImage is the BasicFrameworkImageBase implementation for FrameworkImageBase.
            func (fib FrameworkImageBase) AsTensorFlowFrameworkImage() (*TensorFlowFrameworkImage, bool) {
                return nil, false
            }

            // AsPyTorchFrameworkImage is the BasicFrameworkImageBase implementation for FrameworkImageBase.
            func (fib FrameworkImageBase) AsPyTorchFrameworkImage() (*PyTorchFrameworkImage, bool) {
                return nil, false
            }

            // AsFrameworkImageBase is the BasicFrameworkImageBase implementation for FrameworkImageBase.
            func (fib FrameworkImageBase) AsFrameworkImageBase() (*FrameworkImageBase, bool) {
                return &fib, true
            }

                // AsBasicFrameworkImageBase is the BasicFrameworkImageBase implementation for FrameworkImageBase.
                func(fib FrameworkImageBase) AsBasicFrameworkImageBase()(BasicFrameworkImageBase, bool) {
                    return &fib, true
                }


        // GroupPolicyCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
        // operation.
        type GroupPolicyCreateOrUpdateFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *GroupPolicyCreateOrUpdateFuture) Result(client GroupPolicyClient) (gprd GroupPolicyResourceDescription, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.GroupPolicyCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("microsoftazuremanagementaisupercomputer.GroupPolicyCreateOrUpdateFuture")
        return
        }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if gprd.Response.Response, err = future.GetResult(sender); err == nil && gprd.Response.Response.StatusCode != http.StatusNoContent {
            gprd, err = client.CreateOrUpdateResponder(gprd.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.GroupPolicyCreateOrUpdateFuture", "Result", gprd.Response.Response, "Failure responding to request")
            }
            }
            return
        }

        // GroupPolicyDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
        // operation.
        type GroupPolicyDeleteFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *GroupPolicyDeleteFuture) Result(client GroupPolicyClient) (ar autorest.Response, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.GroupPolicyDeleteFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("microsoftazuremanagementaisupercomputer.GroupPolicyDeleteFuture")
        return
        }
            ar.Response = future.Response()
        return
        }

        // GroupPolicyPatchProperties describes all properties which can be updated for a Singularity group policy
        // resource.
        type GroupPolicyPatchProperties struct {
        // Description - User-friendly description of the resource.
        Description *string `json:"description,omitempty"`
        // Quotas - A list of quota policy per instance type series.
        Quotas *[]InstanceTypeSeriesQuota `json:"quotas,omitempty"`
        // MaxSharedStorageIOPs - Maximum allowed IOPS from shared storageContainer.
        MaxSharedStorageIOPs *int32 `json:"maxSharedStorageIOPs,omitempty"`
        // MaxSharedStorageBandwidth - Maximum allowed bandwidth from shared storageContainer expressed in MB/s.
        MaxSharedStorageBandwidth *int32 `json:"maxSharedStorageBandwidth,omitempty"`
        }

        // GroupPolicyProperties describes the properties of a GroupPolicy resource.
        type GroupPolicyProperties struct {
        // ProvisioningState - Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled', 'ProvisioningStateCreating', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting'
        ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
        // Status - Possible values include: 'PolicyStatusCreating', 'PolicyStatusCreated', 'PolicyStatusUpdating', 'PolicyStatusDeleting', 'PolicyStatusFailed'
        Status PolicyStatus `json:"status,omitempty"`
        // Description - User-friendly description of the resource.
        Description *string `json:"description,omitempty"`
        // Quotas - A list of quota policy per instance type series.
        Quotas *[]InstanceTypeSeriesQuota `json:"quotas,omitempty"`
        // MaxSharedStorageIOPs - Maximum allowed IOPS from shared storageContainer.
        MaxSharedStorageIOPs *int32 `json:"maxSharedStorageIOPs,omitempty"`
        // MaxSharedStorageBandwidth - Maximum allowed bandwidth from shared storageContainer expressed in MB/s.
        MaxSharedStorageBandwidth *int32 `json:"maxSharedStorageBandwidth,omitempty"`
        }

        // GroupPolicyResourceDescription describes a GroupPolicy resource in Singularity.
        type GroupPolicyResourceDescription struct {
        autorest.Response `json:"-"`
        *GroupPolicyResourceDescriptionProperties `json:"properties,omitempty"`
        // ID - READ-ONLY; Fully qualified identifier for the resource. For example, '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}'
        ID *string `json:"id,omitempty"`
        // Name - READ-ONLY; The name of the resource
        Name *string `json:"name,omitempty"`
        // Type - READ-ONLY; The type of the resource. For example, 'Microsoft.Compute/virtualMachines' or 'Microsoft.Storage/storageAccounts'.
        Type *string `json:"type,omitempty"`
        SystemData *ResourceSystemData `json:"systemData,omitempty"`
        }

        // MarshalJSON is the custom marshaler for GroupPolicyResourceDescription.
        func (gprd GroupPolicyResourceDescription)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(gprd.GroupPolicyResourceDescriptionProperties != nil) {
                objectMap["properties"] = gprd.GroupPolicyResourceDescriptionProperties
                }
                if(gprd.SystemData != nil) {
                objectMap["systemData"] = gprd.SystemData
                }
                return json.Marshal(objectMap)
        }
        // UnmarshalJSON is the custom unmarshaler for GroupPolicyResourceDescription struct.
        func (gprd *GroupPolicyResourceDescription) UnmarshalJSON(body []byte) error {
        var m map[string]*json.RawMessage
        err := json.Unmarshal(body, &m)
        if err != nil {
        return err
        }
        for k, v := range  m {
        switch k {
                case "properties":
    if v != nil {
        var groupPolicyResourceDescriptionProperties GroupPolicyResourceDescriptionProperties
        err = json.Unmarshal(*v, &groupPolicyResourceDescriptionProperties)
        if err != nil {
    return err
    }
        gprd.GroupPolicyResourceDescriptionProperties = &groupPolicyResourceDescriptionProperties
    }
                case "id":
    if v != nil {
        var ID string
        err = json.Unmarshal(*v, &ID)
        if err != nil {
    return err
    }
        gprd.ID = &ID
    }
                case "name":
    if v != nil {
        var name string
        err = json.Unmarshal(*v, &name)
        if err != nil {
    return err
    }
        gprd.Name = &name
    }
                case "type":
    if v != nil {
        var typeVar string
        err = json.Unmarshal(*v, &typeVar)
        if err != nil {
    return err
    }
        gprd.Type = &typeVar
    }
                case "systemData":
    if v != nil {
        var systemData ResourceSystemData
        err = json.Unmarshal(*v, &systemData)
        if err != nil {
    return err
    }
        gprd.SystemData = &systemData
    }
            }
        }

        return nil
        }

        // GroupPolicyResourceDescriptionList a pageable list of GroupPolicy resources.
        type GroupPolicyResourceDescriptionList struct {
        autorest.Response `json:"-"`
        // Value - READ-ONLY; One page of the list.
        Value *[]GroupPolicyResourceDescription `json:"value,omitempty"`
        // NextLink - READ-ONLY; URI to fetch the next page of the list.
        NextLink *string `json:"nextLink,omitempty"`
        }

        // GroupPolicyResourceDescriptionListIterator provides access to a complete listing of
        // GroupPolicyResourceDescription values.
        type GroupPolicyResourceDescriptionListIterator struct {
            i int
            page GroupPolicyResourceDescriptionListPage
        }
        // NextWithContext advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        func (iter * GroupPolicyResourceDescriptionListIterator) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/GroupPolicyResourceDescriptionListIterator.NextWithContext")
        defer func() {
        sc := -1
        if iter.Response().Response.Response != nil {
        sc = iter.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        iter.i++
        if iter.i < len(iter. page.Values()) {
        return nil
        }
        err = iter.page.NextWithContext(ctx)
        if err != nil {
        iter. i--
        return err
        }
        iter.i = 0
        return nil
        }
        // Next advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (iter * GroupPolicyResourceDescriptionListIterator) Next() error {
        return iter.NextWithContext(context.Background())
        }
        // NotDone returns true if the enumeration should be started or is not yet complete.
        func (iter GroupPolicyResourceDescriptionListIterator) NotDone() bool {
        return iter.page.NotDone() && iter.i < len(iter. page.Values())
        }
        // Response returns the raw server response from the last page request.
        func (iter GroupPolicyResourceDescriptionListIterator) Response() GroupPolicyResourceDescriptionList {
        return iter.page.Response()
        }
        // Value returns the current value or a zero-initialized value if the
        // iterator has advanced beyond the end of the collection.
        func (iter GroupPolicyResourceDescriptionListIterator) Value() GroupPolicyResourceDescription {
        if !iter.page.NotDone() {
        return GroupPolicyResourceDescription{}
        }
        return iter.page.Values()[iter.i]
        }
        // Creates a new instance of the GroupPolicyResourceDescriptionListIterator type.
        func NewGroupPolicyResourceDescriptionListIterator (page GroupPolicyResourceDescriptionListPage) GroupPolicyResourceDescriptionListIterator {
            return GroupPolicyResourceDescriptionListIterator{page: page}
        }


            // IsEmpty returns true if the ListResult contains no values.
            func (gprdl GroupPolicyResourceDescriptionList) IsEmpty() bool {
            return gprdl.Value == nil || len(*gprdl.Value) == 0
            }

            // hasNextLink returns true if the NextLink is not empty.
            func (gprdl GroupPolicyResourceDescriptionList) hasNextLink() bool {
            return gprdl.NextLink != nil && len(*gprdl.NextLink) != 0
            }
                // groupPolicyResourceDescriptionListPreparer prepares a request to retrieve the next set of results.
                // It returns nil if no more results exist.
                func (gprdl GroupPolicyResourceDescriptionList) groupPolicyResourceDescriptionListPreparer(ctx context.Context) (*http.Request, error) {
                if !gprdl.hasNextLink() {
                return nil, nil
                }
                return autorest.Prepare((&http.Request{}).WithContext(ctx),
                autorest.AsJSON(),
                autorest.AsGet(),
                autorest.WithBaseURL(to.String( gprdl.NextLink)));
                }

        // GroupPolicyResourceDescriptionListPage contains a page of GroupPolicyResourceDescription values.
        type GroupPolicyResourceDescriptionListPage struct {
            fn func(context.Context, GroupPolicyResourceDescriptionList) (GroupPolicyResourceDescriptionList, error)
            gprdl GroupPolicyResourceDescriptionList
        }

        // NextWithContext advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        func (page * GroupPolicyResourceDescriptionListPage) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/GroupPolicyResourceDescriptionListPage.NextWithContext")
        defer func() {
        sc := -1
        if page.Response().Response.Response != nil {
        sc = page.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        for {
            next, err := page.fn(ctx, page.gprdl)
            if err != nil {
            return err
            }
            page.gprdl = next
            if !next.hasNextLink() || !next.IsEmpty() {
                break
            }
        }
        return nil
        }

        // Next advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (page * GroupPolicyResourceDescriptionListPage) Next() error {
        return page.NextWithContext(context.Background())
        }
        // NotDone returns true if the page enumeration should be started or is not yet complete.
        func (page GroupPolicyResourceDescriptionListPage) NotDone() bool {
        return !page.gprdl.IsEmpty()
        }
        // Response returns the raw server response from the last page request.
        func (page GroupPolicyResourceDescriptionListPage) Response() GroupPolicyResourceDescriptionList {
        return page.gprdl
        }
        // Values returns the slice of values for the current page or nil if there are no values.
        func (page GroupPolicyResourceDescriptionListPage) Values() []GroupPolicyResourceDescription {
        if page.gprdl.IsEmpty() {
        return nil
        }
        return *page.gprdl.Value
        }
        // Creates a new instance of the GroupPolicyResourceDescriptionListPage type.
        func NewGroupPolicyResourceDescriptionListPage (getNextPage func(context.Context, GroupPolicyResourceDescriptionList) (GroupPolicyResourceDescriptionList, error)) GroupPolicyResourceDescriptionListPage {
            return GroupPolicyResourceDescriptionListPage{fn: getNextPage}
        }

        // GroupPolicyResourceDescriptionProperties ...
        type GroupPolicyResourceDescriptionProperties struct {
        // ProvisioningState - Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled', 'ProvisioningStateCreating', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting'
        ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
        // Status - Possible values include: 'PolicyStatusCreating', 'PolicyStatusCreated', 'PolicyStatusUpdating', 'PolicyStatusDeleting', 'PolicyStatusFailed'
        Status PolicyStatus `json:"status,omitempty"`
        // Description - User-friendly description of the resource.
        Description *string `json:"description,omitempty"`
        // Quotas - A list of quota policy per instance type series.
        Quotas *[]InstanceTypeSeriesQuota `json:"quotas,omitempty"`
        // MaxSharedStorageIOPs - Maximum allowed IOPS from shared storageContainer.
        MaxSharedStorageIOPs *int32 `json:"maxSharedStorageIOPs,omitempty"`
        // MaxSharedStorageBandwidth - Maximum allowed bandwidth from shared storageContainer expressed in MB/s.
        MaxSharedStorageBandwidth *int32 `json:"maxSharedStorageBandwidth,omitempty"`
        }

        // GroupPolicyResourcePatchDescription describes all properties which can be updated for a Singularity group
        // policy resource.
        type GroupPolicyResourcePatchDescription struct {
        *GroupPolicyResourcePatchDescriptionProperties `json:"properties,omitempty"`
        // ID - READ-ONLY; Fully qualified identifier for the resource. For example, '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}'
        ID *string `json:"id,omitempty"`
        // Name - READ-ONLY; The name of the resource
        Name *string `json:"name,omitempty"`
        // Type - READ-ONLY; The type of the resource. For example, 'Microsoft.Compute/virtualMachines' or 'Microsoft.Storage/storageAccounts'.
        Type *string `json:"type,omitempty"`
        SystemData *ResourceSystemData `json:"systemData,omitempty"`
        }

        // MarshalJSON is the custom marshaler for GroupPolicyResourcePatchDescription.
        func (gprpd GroupPolicyResourcePatchDescription)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(gprpd.GroupPolicyResourcePatchDescriptionProperties != nil) {
                objectMap["properties"] = gprpd.GroupPolicyResourcePatchDescriptionProperties
                }
                if(gprpd.SystemData != nil) {
                objectMap["systemData"] = gprpd.SystemData
                }
                return json.Marshal(objectMap)
        }
        // UnmarshalJSON is the custom unmarshaler for GroupPolicyResourcePatchDescription struct.
        func (gprpd *GroupPolicyResourcePatchDescription) UnmarshalJSON(body []byte) error {
        var m map[string]*json.RawMessage
        err := json.Unmarshal(body, &m)
        if err != nil {
        return err
        }
        for k, v := range  m {
        switch k {
                case "properties":
    if v != nil {
        var groupPolicyResourcePatchDescriptionProperties GroupPolicyResourcePatchDescriptionProperties
        err = json.Unmarshal(*v, &groupPolicyResourcePatchDescriptionProperties)
        if err != nil {
    return err
    }
        gprpd.GroupPolicyResourcePatchDescriptionProperties = &groupPolicyResourcePatchDescriptionProperties
    }
                case "id":
    if v != nil {
        var ID string
        err = json.Unmarshal(*v, &ID)
        if err != nil {
    return err
    }
        gprpd.ID = &ID
    }
                case "name":
    if v != nil {
        var name string
        err = json.Unmarshal(*v, &name)
        if err != nil {
    return err
    }
        gprpd.Name = &name
    }
                case "type":
    if v != nil {
        var typeVar string
        err = json.Unmarshal(*v, &typeVar)
        if err != nil {
    return err
    }
        gprpd.Type = &typeVar
    }
                case "systemData":
    if v != nil {
        var systemData ResourceSystemData
        err = json.Unmarshal(*v, &systemData)
        if err != nil {
    return err
    }
        gprpd.SystemData = &systemData
    }
            }
        }

        return nil
        }

        // GroupPolicyResourcePatchDescriptionProperties ...
        type GroupPolicyResourcePatchDescriptionProperties struct {
        // Description - User-friendly description of the resource.
        Description *string `json:"description,omitempty"`
        // Quotas - A list of quota policy per instance type series.
        Quotas *[]InstanceTypeSeriesQuota `json:"quotas,omitempty"`
        // MaxSharedStorageIOPs - Maximum allowed IOPS from shared storageContainer.
        MaxSharedStorageIOPs *int32 `json:"maxSharedStorageIOPs,omitempty"`
        // MaxSharedStorageBandwidth - Maximum allowed bandwidth from shared storageContainer expressed in MB/s.
        MaxSharedStorageBandwidth *int32 `json:"maxSharedStorageBandwidth,omitempty"`
        }

        // GroupPolicyUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
        // operation.
        type GroupPolicyUpdateFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *GroupPolicyUpdateFuture) Result(client GroupPolicyClient) (gprd GroupPolicyResourceDescription, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.GroupPolicyUpdateFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("microsoftazuremanagementaisupercomputer.GroupPolicyUpdateFuture")
        return
        }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if gprd.Response.Response, err = future.GetResult(sender); err == nil && gprd.Response.Response.StatusCode != http.StatusNoContent {
            gprd, err = client.UpdateResponder(gprd.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.GroupPolicyUpdateFuture", "Result", gprd.Response.Response, "Failure responding to request")
            }
            }
            return
        }

        // IdleResourcesHandlingPolicy describes the properties of idle resources handling policy.
        type IdleResourcesHandlingPolicy struct {
        // IdleResourcesHandlingMode - Possible values include: 'AutoSuspend', 'AutoDelete'
        IdleResourcesHandlingMode IdleResourcesHandlingMode `json:"idleResourcesHandlingMode,omitempty"`
        }

        // InstanceTypeSeriesQuota describes the quota for the InstanceType series.
        type InstanceTypeSeriesQuota struct {
        // ID - The identifier for instance type series quota.
        ID *string `json:"id,omitempty"`
        // Name - READ-ONLY; User friendly description for the instance type series.
        Name *string `json:"name,omitempty"`
        // Limit - Maximum allowed units for the instance type series.
        Limit *int64 `json:"limit,omitempty"`
        // Used - READ-ONLY; Number of units currently in use.
        Used *int64 `json:"used,omitempty"`
        }

        // MarshalJSON is the custom marshaler for InstanceTypeSeriesQuota.
        func (itsq InstanceTypeSeriesQuota)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(itsq.ID != nil) {
                objectMap["id"] = itsq.ID
                }
                if(itsq.Limit != nil) {
                objectMap["limit"] = itsq.Limit
                }
                return json.Marshal(objectMap)
        }

        // InstanceTypeSettings describes the instance type settings.
        type InstanceTypeSettings struct {
        // InstanceType - The instance type belonging to the same series.
        InstanceType *string `json:"instanceType,omitempty"`
        ScalePolicy *ScalePolicy `json:"scalePolicy,omitempty"`
        }

        // JobApproveFuture an abstraction for monitoring and retrieving the results of a long-running operation.
        type JobApproveFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *JobApproveFuture) Result(client JobClient) (ar autorest.Response, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.JobApproveFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("microsoftazuremanagementaisupercomputer.JobApproveFuture")
        return
        }
            ar.Response = future.Response()
        return
        }

        // JobCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
        // operation.
        type JobCreateOrUpdateFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *JobCreateOrUpdateFuture) Result(client JobClient) (jrd JobResourceDescription, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.JobCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("microsoftazuremanagementaisupercomputer.JobCreateOrUpdateFuture")
        return
        }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if jrd.Response.Response, err = future.GetResult(sender); err == nil && jrd.Response.Response.StatusCode != http.StatusNoContent {
            jrd, err = client.CreateOrUpdateResponder(jrd.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.JobCreateOrUpdateFuture", "Result", jrd.Response.Response, "Failure responding to request")
            }
            }
            return
        }

        // JobCreateSasTokenFuture an abstraction for monitoring and retrieving the results of a long-running
        // operation.
        type JobCreateSasTokenFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *JobCreateSasTokenFuture) Result(client JobClient) (jstd JobSasTokenDescription, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.JobCreateSasTokenFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("microsoftazuremanagementaisupercomputer.JobCreateSasTokenFuture")
        return
        }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if jstd.Response.Response, err = future.GetResult(sender); err == nil && jstd.Response.Response.StatusCode != http.StatusNoContent {
            jstd, err = client.CreateSasTokenResponder(jstd.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.JobCreateSasTokenFuture", "Result", jstd.Response.Response, "Failure responding to request")
            }
            }
            return
        }

        // JobDeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
        type JobDeleteFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *JobDeleteFuture) Result(client JobClient) (ar autorest.Response, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.JobDeleteFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("microsoftazuremanagementaisupercomputer.JobDeleteFuture")
        return
        }
            ar.Response = future.Response()
        return
        }

        // JobPatchProperties describes all properties which can be updated for a Singularity job resource.
        type JobPatchProperties struct {
        // Description - User-friendly description of the job.
        Description *string `json:"description,omitempty"`
        // SchedulingPriority - Possible values include: 'Low', 'Medium', 'High'
        SchedulingPriority SchedulingPriority `json:"schedulingPriority,omitempty"`
        }

        // JobRemoveFuture an abstraction for monitoring and retrieving the results of a long-running operation.
        type JobRemoveFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *JobRemoveFuture) Result(client JobClient) (ar autorest.Response, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.JobRemoveFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("microsoftazuremanagementaisupercomputer.JobRemoveFuture")
        return
        }
            ar.Response = future.Response()
        return
        }

        // JobResourceDescription describes a job resource in Singularity.
        type JobResourceDescription struct {
        autorest.Response `json:"-"`
        *JobResourceDescriptionProperties `json:"properties,omitempty"`
        Identity *ResourceIdentity `json:"identity,omitempty"`
        // ID - READ-ONLY; Fully qualified identifier for the resource. For example, '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}'
        ID *string `json:"id,omitempty"`
        // Name - READ-ONLY; The name of the resource
        Name *string `json:"name,omitempty"`
        // Type - READ-ONLY; The type of the resource. For example, 'Microsoft.Compute/virtualMachines' or 'Microsoft.Storage/storageAccounts'.
        Type *string `json:"type,omitempty"`
        SystemData *ResourceSystemData `json:"systemData,omitempty"`
        }

        // MarshalJSON is the custom marshaler for JobResourceDescription.
        func (jrd JobResourceDescription)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(jrd.JobResourceDescriptionProperties != nil) {
                objectMap["properties"] = jrd.JobResourceDescriptionProperties
                }
                if(jrd.Identity != nil) {
                objectMap["identity"] = jrd.Identity
                }
                if(jrd.SystemData != nil) {
                objectMap["systemData"] = jrd.SystemData
                }
                return json.Marshal(objectMap)
        }
        // UnmarshalJSON is the custom unmarshaler for JobResourceDescription struct.
        func (jrd *JobResourceDescription) UnmarshalJSON(body []byte) error {
        var m map[string]*json.RawMessage
        err := json.Unmarshal(body, &m)
        if err != nil {
        return err
        }
        for k, v := range  m {
        switch k {
                case "properties":
    if v != nil {
        var jobResourceDescriptionProperties JobResourceDescriptionProperties
        err = json.Unmarshal(*v, &jobResourceDescriptionProperties)
        if err != nil {
    return err
    }
        jrd.JobResourceDescriptionProperties = &jobResourceDescriptionProperties
    }
                case "identity":
    if v != nil {
        var identity ResourceIdentity
        err = json.Unmarshal(*v, &identity)
        if err != nil {
    return err
    }
        jrd.Identity = &identity
    }
                case "id":
    if v != nil {
        var ID string
        err = json.Unmarshal(*v, &ID)
        if err != nil {
    return err
    }
        jrd.ID = &ID
    }
                case "name":
    if v != nil {
        var name string
        err = json.Unmarshal(*v, &name)
        if err != nil {
    return err
    }
        jrd.Name = &name
    }
                case "type":
    if v != nil {
        var typeVar string
        err = json.Unmarshal(*v, &typeVar)
        if err != nil {
    return err
    }
        jrd.Type = &typeVar
    }
                case "systemData":
    if v != nil {
        var systemData ResourceSystemData
        err = json.Unmarshal(*v, &systemData)
        if err != nil {
    return err
    }
        jrd.SystemData = &systemData
    }
            }
        }

        return nil
        }

        // JobResourceDescriptionList a pageable list of Job resources.
        type JobResourceDescriptionList struct {
        autorest.Response `json:"-"`
        // Value - READ-ONLY; One page of the list.
        Value *[]JobResourceDescription `json:"value,omitempty"`
        // NextLink - READ-ONLY; URI to fetch the next page of the list.
        NextLink *string `json:"nextLink,omitempty"`
        }

        // JobResourceDescriptionListIterator provides access to a complete listing of JobResourceDescription values.
        type JobResourceDescriptionListIterator struct {
            i int
            page JobResourceDescriptionListPage
        }
        // NextWithContext advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        func (iter * JobResourceDescriptionListIterator) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/JobResourceDescriptionListIterator.NextWithContext")
        defer func() {
        sc := -1
        if iter.Response().Response.Response != nil {
        sc = iter.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        iter.i++
        if iter.i < len(iter. page.Values()) {
        return nil
        }
        err = iter.page.NextWithContext(ctx)
        if err != nil {
        iter. i--
        return err
        }
        iter.i = 0
        return nil
        }
        // Next advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (iter * JobResourceDescriptionListIterator) Next() error {
        return iter.NextWithContext(context.Background())
        }
        // NotDone returns true if the enumeration should be started or is not yet complete.
        func (iter JobResourceDescriptionListIterator) NotDone() bool {
        return iter.page.NotDone() && iter.i < len(iter. page.Values())
        }
        // Response returns the raw server response from the last page request.
        func (iter JobResourceDescriptionListIterator) Response() JobResourceDescriptionList {
        return iter.page.Response()
        }
        // Value returns the current value or a zero-initialized value if the
        // iterator has advanced beyond the end of the collection.
        func (iter JobResourceDescriptionListIterator) Value() JobResourceDescription {
        if !iter.page.NotDone() {
        return JobResourceDescription{}
        }
        return iter.page.Values()[iter.i]
        }
        // Creates a new instance of the JobResourceDescriptionListIterator type.
        func NewJobResourceDescriptionListIterator (page JobResourceDescriptionListPage) JobResourceDescriptionListIterator {
            return JobResourceDescriptionListIterator{page: page}
        }


            // IsEmpty returns true if the ListResult contains no values.
            func (jrdl JobResourceDescriptionList) IsEmpty() bool {
            return jrdl.Value == nil || len(*jrdl.Value) == 0
            }

            // hasNextLink returns true if the NextLink is not empty.
            func (jrdl JobResourceDescriptionList) hasNextLink() bool {
            return jrdl.NextLink != nil && len(*jrdl.NextLink) != 0
            }
                // jobResourceDescriptionListPreparer prepares a request to retrieve the next set of results.
                // It returns nil if no more results exist.
                func (jrdl JobResourceDescriptionList) jobResourceDescriptionListPreparer(ctx context.Context) (*http.Request, error) {
                if !jrdl.hasNextLink() {
                return nil, nil
                }
                return autorest.Prepare((&http.Request{}).WithContext(ctx),
                autorest.AsJSON(),
                autorest.AsGet(),
                autorest.WithBaseURL(to.String( jrdl.NextLink)));
                }

        // JobResourceDescriptionListPage contains a page of JobResourceDescription values.
        type JobResourceDescriptionListPage struct {
            fn func(context.Context, JobResourceDescriptionList) (JobResourceDescriptionList, error)
            jrdl JobResourceDescriptionList
        }

        // NextWithContext advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        func (page * JobResourceDescriptionListPage) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/JobResourceDescriptionListPage.NextWithContext")
        defer func() {
        sc := -1
        if page.Response().Response.Response != nil {
        sc = page.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        for {
            next, err := page.fn(ctx, page.jrdl)
            if err != nil {
            return err
            }
            page.jrdl = next
            if !next.hasNextLink() || !next.IsEmpty() {
                break
            }
        }
        return nil
        }

        // Next advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (page * JobResourceDescriptionListPage) Next() error {
        return page.NextWithContext(context.Background())
        }
        // NotDone returns true if the page enumeration should be started or is not yet complete.
        func (page JobResourceDescriptionListPage) NotDone() bool {
        return !page.jrdl.IsEmpty()
        }
        // Response returns the raw server response from the last page request.
        func (page JobResourceDescriptionListPage) Response() JobResourceDescriptionList {
        return page.jrdl
        }
        // Values returns the slice of values for the current page or nil if there are no values.
        func (page JobResourceDescriptionListPage) Values() []JobResourceDescription {
        if page.jrdl.IsEmpty() {
        return nil
        }
        return *page.jrdl.Value
        }
        // Creates a new instance of the JobResourceDescriptionListPage type.
        func NewJobResourceDescriptionListPage (getNextPage func(context.Context, JobResourceDescriptionList) (JobResourceDescriptionList, error)) JobResourceDescriptionListPage {
            return JobResourceDescriptionListPage{fn: getNextPage}
        }

        // JobResourceDescriptionProperties ...
        type JobResourceDescriptionProperties struct {
        // ProvisioningState - Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled', 'ProvisioningStateCreating', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting'
        ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
        // JobID - READ-ONLY; System generated globally unique id for the job. This property is read only.
        JobID *string `json:"jobId,omitempty"`
        // PlacementPolicies - Collection of placement policies to use for the training job.
        PlacementPolicies *[]PlacementPolicy `json:"placementPolicies,omitempty"`
        // SchedulingPriority - Possible values include: 'Low', 'Medium', 'High'
        SchedulingPriority SchedulingPriority `json:"schedulingPriority,omitempty"`
        // DataLocation - Job input data location.
        DataLocation *[]StorageLocation `json:"dataLocation,omitempty"`
        CodeLocation *StorageLocation `json:"codeLocation,omitempty"`
        OutputLocation *StorageLocation `json:"outputLocation,omitempty"`
        FrameworkImage BasicFrameworkImageBase `json:"frameworkImage,omitempty"`
        // GroupPolicyName - Group policy name associated with the training job.
        GroupPolicyName *string `json:"groupPolicyName,omitempty"`
        CheckpointPolicy *CheckpointPolicy `json:"checkpointPolicy,omitempty"`
        CompilationPolicy *CompilationPolicy `json:"compilationPolicy,omitempty"`
        DeploymentPolicy *DeploymentPolicy `json:"deploymentPolicy,omitempty"`
        // MaxJobExecutionTime - Maximum execution time for a training job in the account (in hours).
        MaxJobExecutionTime *float64 `json:"maxJobExecutionTime,omitempty"`
        // Program - The entry script for your Job in the codeLocation. For interactive jobs, specify null.
        Program *string `json:"program,omitempty"`
        // ProgramArgs - Command line arguments to be passed to the program.
        ProgramArgs *string `json:"programArgs,omitempty"`
        // TensorBoardLogDirectory - The directory which TensorBoard will be configured to use as the log directory.
        TensorBoardLogDirectory *string `json:"tensorBoardLogDirectory,omitempty"`
        // Status - Possible values include: 'JobStatusCreating', 'JobStatusCreated', 'JobStatusApproving', 'JobStatusApproved', 'JobStatusStarting', 'JobStatusRunning', 'JobStatusSuspending', 'JobStatusSuspended', 'JobStatusResuming', 'JobStatusDeleting', 'JobStatusError', 'JobStatusFailed', 'JobStatusCompleted'
        Status JobStatus `json:"status,omitempty"`
        // Description - User-friendly description of the job.
        Description *string `json:"description,omitempty"`
        // StatusDetails - READ-ONLY; Gives additional information about the current status of the job.
        StatusDetails *string `json:"statusDetails,omitempty"`
        // NotebookEndpoint - READ-ONLY; Url to access Jupyter notebook endpoint of the job.
        NotebookEndpoint *string `json:"notebookEndpoint,omitempty"`
        // TensorBoardEndpoint - READ-ONLY; Url to access TensorBoard endpoint of the job.
        TensorBoardEndpoint *string `json:"tensorBoardEndpoint,omitempty"`
        // GrafanaEndpoint - READ-ONLY; Url to access Grafana endpoint of the job.
        GrafanaEndpoint *string `json:"grafanaEndpoint,omitempty"`
        // JobLogsEndpoint - READ-ONLY; Url to access logs of the job.
        JobLogsEndpoint *string `json:"jobLogsEndpoint,omitempty"`
        }

        // MarshalJSON is the custom marshaler for JobResourceDescriptionProperties.
        func (jrd JobResourceDescriptionProperties)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(jrd.ProvisioningState != "") {
                objectMap["provisioningState"] = jrd.ProvisioningState
                }
                if(jrd.PlacementPolicies != nil) {
                objectMap["placementPolicies"] = jrd.PlacementPolicies
                }
                if(jrd.SchedulingPriority != "") {
                objectMap["schedulingPriority"] = jrd.SchedulingPriority
                }
                if(jrd.DataLocation != nil) {
                objectMap["dataLocation"] = jrd.DataLocation
                }
                if(jrd.CodeLocation != nil) {
                objectMap["codeLocation"] = jrd.CodeLocation
                }
                if(jrd.OutputLocation != nil) {
                objectMap["outputLocation"] = jrd.OutputLocation
                }
                objectMap["frameworkImage"] = jrd.FrameworkImage
                if(jrd.GroupPolicyName != nil) {
                objectMap["groupPolicyName"] = jrd.GroupPolicyName
                }
                if(jrd.CheckpointPolicy != nil) {
                objectMap["checkpointPolicy"] = jrd.CheckpointPolicy
                }
                if(jrd.CompilationPolicy != nil) {
                objectMap["compilationPolicy"] = jrd.CompilationPolicy
                }
                if(jrd.DeploymentPolicy != nil) {
                objectMap["deploymentPolicy"] = jrd.DeploymentPolicy
                }
                if(jrd.MaxJobExecutionTime != nil) {
                objectMap["maxJobExecutionTime"] = jrd.MaxJobExecutionTime
                }
                if(jrd.Program != nil) {
                objectMap["program"] = jrd.Program
                }
                if(jrd.ProgramArgs != nil) {
                objectMap["programArgs"] = jrd.ProgramArgs
                }
                if(jrd.TensorBoardLogDirectory != nil) {
                objectMap["tensorBoardLogDirectory"] = jrd.TensorBoardLogDirectory
                }
                if(jrd.Status != "") {
                objectMap["status"] = jrd.Status
                }
                if(jrd.Description != nil) {
                objectMap["description"] = jrd.Description
                }
                return json.Marshal(objectMap)
        }
        // UnmarshalJSON is the custom unmarshaler for JobResourceDescriptionProperties struct.
        func (jrd *JobResourceDescriptionProperties) UnmarshalJSON(body []byte) error {
        var m map[string]*json.RawMessage
        err := json.Unmarshal(body, &m)
        if err != nil {
        return err
        }
        for k, v := range  m {
        switch k {
                case "provisioningState":
    if v != nil {
        var provisioningState ProvisioningState
        err = json.Unmarshal(*v, &provisioningState)
        if err != nil {
    return err
    }
        jrd.ProvisioningState = provisioningState
    }
                case "jobId":
    if v != nil {
        var jobID string
        err = json.Unmarshal(*v, &jobID)
        if err != nil {
    return err
    }
        jrd.JobID = &jobID
    }
                case "placementPolicies":
    if v != nil {
        var placementPolicies []PlacementPolicy
        err = json.Unmarshal(*v, &placementPolicies)
        if err != nil {
    return err
    }
        jrd.PlacementPolicies = &placementPolicies
    }
                case "schedulingPriority":
    if v != nil {
        var schedulingPriority SchedulingPriority
        err = json.Unmarshal(*v, &schedulingPriority)
        if err != nil {
    return err
    }
        jrd.SchedulingPriority = schedulingPriority
    }
                case "dataLocation":
    if v != nil {
        var dataLocation []StorageLocation
        err = json.Unmarshal(*v, &dataLocation)
        if err != nil {
    return err
    }
        jrd.DataLocation = &dataLocation
    }
                case "codeLocation":
    if v != nil {
        var codeLocation StorageLocation
        err = json.Unmarshal(*v, &codeLocation)
        if err != nil {
    return err
    }
        jrd.CodeLocation = &codeLocation
    }
                case "outputLocation":
    if v != nil {
        var outputLocation StorageLocation
        err = json.Unmarshal(*v, &outputLocation)
        if err != nil {
    return err
    }
        jrd.OutputLocation = &outputLocation
    }
                case "frameworkImage":
    if v != nil {
        frameworkImage, err := unmarshalBasicFrameworkImageBase(*v)
    if err != nil {
    return err
    }
        jrd.FrameworkImage = frameworkImage
    }
                case "groupPolicyName":
    if v != nil {
        var groupPolicyName string
        err = json.Unmarshal(*v, &groupPolicyName)
        if err != nil {
    return err
    }
        jrd.GroupPolicyName = &groupPolicyName
    }
                case "checkpointPolicy":
    if v != nil {
        var checkpointPolicy CheckpointPolicy
        err = json.Unmarshal(*v, &checkpointPolicy)
        if err != nil {
    return err
    }
        jrd.CheckpointPolicy = &checkpointPolicy
    }
                case "compilationPolicy":
    if v != nil {
        var compilationPolicy CompilationPolicy
        err = json.Unmarshal(*v, &compilationPolicy)
        if err != nil {
    return err
    }
        jrd.CompilationPolicy = &compilationPolicy
    }
                case "deploymentPolicy":
    if v != nil {
        var deploymentPolicy DeploymentPolicy
        err = json.Unmarshal(*v, &deploymentPolicy)
        if err != nil {
    return err
    }
        jrd.DeploymentPolicy = &deploymentPolicy
    }
                case "maxJobExecutionTime":
    if v != nil {
        var maxJobExecutionTime float64
        err = json.Unmarshal(*v, &maxJobExecutionTime)
        if err != nil {
    return err
    }
        jrd.MaxJobExecutionTime = &maxJobExecutionTime
    }
                case "program":
    if v != nil {
        var program string
        err = json.Unmarshal(*v, &program)
        if err != nil {
    return err
    }
        jrd.Program = &program
    }
                case "programArgs":
    if v != nil {
        var programArgs string
        err = json.Unmarshal(*v, &programArgs)
        if err != nil {
    return err
    }
        jrd.ProgramArgs = &programArgs
    }
                case "tensorBoardLogDirectory":
    if v != nil {
        var tensorBoardLogDirectory string
        err = json.Unmarshal(*v, &tensorBoardLogDirectory)
        if err != nil {
    return err
    }
        jrd.TensorBoardLogDirectory = &tensorBoardLogDirectory
    }
                case "status":
    if v != nil {
        var status JobStatus
        err = json.Unmarshal(*v, &status)
        if err != nil {
    return err
    }
        jrd.Status = status
    }
                case "description":
    if v != nil {
        var description string
        err = json.Unmarshal(*v, &description)
        if err != nil {
    return err
    }
        jrd.Description = &description
    }
                case "statusDetails":
    if v != nil {
        var statusDetails string
        err = json.Unmarshal(*v, &statusDetails)
        if err != nil {
    return err
    }
        jrd.StatusDetails = &statusDetails
    }
                case "notebookEndpoint":
    if v != nil {
        var notebookEndpoint string
        err = json.Unmarshal(*v, &notebookEndpoint)
        if err != nil {
    return err
    }
        jrd.NotebookEndpoint = &notebookEndpoint
    }
                case "tensorBoardEndpoint":
    if v != nil {
        var tensorBoardEndpoint string
        err = json.Unmarshal(*v, &tensorBoardEndpoint)
        if err != nil {
    return err
    }
        jrd.TensorBoardEndpoint = &tensorBoardEndpoint
    }
                case "grafanaEndpoint":
    if v != nil {
        var grafanaEndpoint string
        err = json.Unmarshal(*v, &grafanaEndpoint)
        if err != nil {
    return err
    }
        jrd.GrafanaEndpoint = &grafanaEndpoint
    }
                case "jobLogsEndpoint":
    if v != nil {
        var jobLogsEndpoint string
        err = json.Unmarshal(*v, &jobLogsEndpoint)
        if err != nil {
    return err
    }
        jrd.JobLogsEndpoint = &jobLogsEndpoint
    }
            }
        }

        return nil
        }

        // JobResourcePatchDescription describes all properties which can be updated for a Singularity job resource.
        type JobResourcePatchDescription struct {
        *JobResourcePatchDescriptionProperties `json:"properties,omitempty"`
        // ID - READ-ONLY; Fully qualified identifier for the resource. For example, '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}'
        ID *string `json:"id,omitempty"`
        // Name - READ-ONLY; The name of the resource
        Name *string `json:"name,omitempty"`
        // Type - READ-ONLY; The type of the resource. For example, 'Microsoft.Compute/virtualMachines' or 'Microsoft.Storage/storageAccounts'.
        Type *string `json:"type,omitempty"`
        SystemData *ResourceSystemData `json:"systemData,omitempty"`
        }

        // MarshalJSON is the custom marshaler for JobResourcePatchDescription.
        func (jrpd JobResourcePatchDescription)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(jrpd.JobResourcePatchDescriptionProperties != nil) {
                objectMap["properties"] = jrpd.JobResourcePatchDescriptionProperties
                }
                if(jrpd.SystemData != nil) {
                objectMap["systemData"] = jrpd.SystemData
                }
                return json.Marshal(objectMap)
        }
        // UnmarshalJSON is the custom unmarshaler for JobResourcePatchDescription struct.
        func (jrpd *JobResourcePatchDescription) UnmarshalJSON(body []byte) error {
        var m map[string]*json.RawMessage
        err := json.Unmarshal(body, &m)
        if err != nil {
        return err
        }
        for k, v := range  m {
        switch k {
                case "properties":
    if v != nil {
        var jobResourcePatchDescriptionProperties JobResourcePatchDescriptionProperties
        err = json.Unmarshal(*v, &jobResourcePatchDescriptionProperties)
        if err != nil {
    return err
    }
        jrpd.JobResourcePatchDescriptionProperties = &jobResourcePatchDescriptionProperties
    }
                case "id":
    if v != nil {
        var ID string
        err = json.Unmarshal(*v, &ID)
        if err != nil {
    return err
    }
        jrpd.ID = &ID
    }
                case "name":
    if v != nil {
        var name string
        err = json.Unmarshal(*v, &name)
        if err != nil {
    return err
    }
        jrpd.Name = &name
    }
                case "type":
    if v != nil {
        var typeVar string
        err = json.Unmarshal(*v, &typeVar)
        if err != nil {
    return err
    }
        jrpd.Type = &typeVar
    }
                case "systemData":
    if v != nil {
        var systemData ResourceSystemData
        err = json.Unmarshal(*v, &systemData)
        if err != nil {
    return err
    }
        jrpd.SystemData = &systemData
    }
            }
        }

        return nil
        }

        // JobResourcePatchDescriptionProperties ...
        type JobResourcePatchDescriptionProperties struct {
        // Description - User-friendly description of the job.
        Description *string `json:"description,omitempty"`
        // SchedulingPriority - Possible values include: 'Low', 'Medium', 'High'
        SchedulingPriority SchedulingPriority `json:"schedulingPriority,omitempty"`
        }

        // JobResourceProperties describes the properties of a job resource.
        type JobResourceProperties struct {
        // ProvisioningState - Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled', 'ProvisioningStateCreating', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting'
        ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
        // JobID - READ-ONLY; System generated globally unique id for the job. This property is read only.
        JobID *string `json:"jobId,omitempty"`
        // PlacementPolicies - Collection of placement policies to use for the training job.
        PlacementPolicies *[]PlacementPolicy `json:"placementPolicies,omitempty"`
        // SchedulingPriority - Possible values include: 'Low', 'Medium', 'High'
        SchedulingPriority SchedulingPriority `json:"schedulingPriority,omitempty"`
        // DataLocation - Job input data location.
        DataLocation *[]StorageLocation `json:"dataLocation,omitempty"`
        CodeLocation *StorageLocation `json:"codeLocation,omitempty"`
        OutputLocation *StorageLocation `json:"outputLocation,omitempty"`
        FrameworkImage BasicFrameworkImageBase `json:"frameworkImage,omitempty"`
        // GroupPolicyName - Group policy name associated with the training job.
        GroupPolicyName *string `json:"groupPolicyName,omitempty"`
        CheckpointPolicy *CheckpointPolicy `json:"checkpointPolicy,omitempty"`
        CompilationPolicy *CompilationPolicy `json:"compilationPolicy,omitempty"`
        DeploymentPolicy *DeploymentPolicy `json:"deploymentPolicy,omitempty"`
        // MaxJobExecutionTime - Maximum execution time for a training job in the account (in hours).
        MaxJobExecutionTime *float64 `json:"maxJobExecutionTime,omitempty"`
        // Program - The entry script for your Job in the codeLocation. For interactive jobs, specify null.
        Program *string `json:"program,omitempty"`
        // ProgramArgs - Command line arguments to be passed to the program.
        ProgramArgs *string `json:"programArgs,omitempty"`
        // TensorBoardLogDirectory - The directory which TensorBoard will be configured to use as the log directory.
        TensorBoardLogDirectory *string `json:"tensorBoardLogDirectory,omitempty"`
        // Status - Possible values include: 'JobStatusCreating', 'JobStatusCreated', 'JobStatusApproving', 'JobStatusApproved', 'JobStatusStarting', 'JobStatusRunning', 'JobStatusSuspending', 'JobStatusSuspended', 'JobStatusResuming', 'JobStatusDeleting', 'JobStatusError', 'JobStatusFailed', 'JobStatusCompleted'
        Status JobStatus `json:"status,omitempty"`
        // Description - User-friendly description of the job.
        Description *string `json:"description,omitempty"`
        // StatusDetails - READ-ONLY; Gives additional information about the current status of the job.
        StatusDetails *string `json:"statusDetails,omitempty"`
        // NotebookEndpoint - READ-ONLY; Url to access Jupyter notebook endpoint of the job.
        NotebookEndpoint *string `json:"notebookEndpoint,omitempty"`
        // TensorBoardEndpoint - READ-ONLY; Url to access TensorBoard endpoint of the job.
        TensorBoardEndpoint *string `json:"tensorBoardEndpoint,omitempty"`
        // GrafanaEndpoint - READ-ONLY; Url to access Grafana endpoint of the job.
        GrafanaEndpoint *string `json:"grafanaEndpoint,omitempty"`
        // JobLogsEndpoint - READ-ONLY; Url to access logs of the job.
        JobLogsEndpoint *string `json:"jobLogsEndpoint,omitempty"`
        }

        // MarshalJSON is the custom marshaler for JobResourceProperties.
        func (jrp JobResourceProperties)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(jrp.ProvisioningState != "") {
                objectMap["provisioningState"] = jrp.ProvisioningState
                }
                if(jrp.PlacementPolicies != nil) {
                objectMap["placementPolicies"] = jrp.PlacementPolicies
                }
                if(jrp.SchedulingPriority != "") {
                objectMap["schedulingPriority"] = jrp.SchedulingPriority
                }
                if(jrp.DataLocation != nil) {
                objectMap["dataLocation"] = jrp.DataLocation
                }
                if(jrp.CodeLocation != nil) {
                objectMap["codeLocation"] = jrp.CodeLocation
                }
                if(jrp.OutputLocation != nil) {
                objectMap["outputLocation"] = jrp.OutputLocation
                }
                objectMap["frameworkImage"] = jrp.FrameworkImage
                if(jrp.GroupPolicyName != nil) {
                objectMap["groupPolicyName"] = jrp.GroupPolicyName
                }
                if(jrp.CheckpointPolicy != nil) {
                objectMap["checkpointPolicy"] = jrp.CheckpointPolicy
                }
                if(jrp.CompilationPolicy != nil) {
                objectMap["compilationPolicy"] = jrp.CompilationPolicy
                }
                if(jrp.DeploymentPolicy != nil) {
                objectMap["deploymentPolicy"] = jrp.DeploymentPolicy
                }
                if(jrp.MaxJobExecutionTime != nil) {
                objectMap["maxJobExecutionTime"] = jrp.MaxJobExecutionTime
                }
                if(jrp.Program != nil) {
                objectMap["program"] = jrp.Program
                }
                if(jrp.ProgramArgs != nil) {
                objectMap["programArgs"] = jrp.ProgramArgs
                }
                if(jrp.TensorBoardLogDirectory != nil) {
                objectMap["tensorBoardLogDirectory"] = jrp.TensorBoardLogDirectory
                }
                if(jrp.Status != "") {
                objectMap["status"] = jrp.Status
                }
                if(jrp.Description != nil) {
                objectMap["description"] = jrp.Description
                }
                return json.Marshal(objectMap)
        }
        // UnmarshalJSON is the custom unmarshaler for JobResourceProperties struct.
        func (jrp *JobResourceProperties) UnmarshalJSON(body []byte) error {
        var m map[string]*json.RawMessage
        err := json.Unmarshal(body, &m)
        if err != nil {
        return err
        }
        for k, v := range  m {
        switch k {
                case "provisioningState":
    if v != nil {
        var provisioningState ProvisioningState
        err = json.Unmarshal(*v, &provisioningState)
        if err != nil {
    return err
    }
        jrp.ProvisioningState = provisioningState
    }
                case "jobId":
    if v != nil {
        var jobID string
        err = json.Unmarshal(*v, &jobID)
        if err != nil {
    return err
    }
        jrp.JobID = &jobID
    }
                case "placementPolicies":
    if v != nil {
        var placementPolicies []PlacementPolicy
        err = json.Unmarshal(*v, &placementPolicies)
        if err != nil {
    return err
    }
        jrp.PlacementPolicies = &placementPolicies
    }
                case "schedulingPriority":
    if v != nil {
        var schedulingPriority SchedulingPriority
        err = json.Unmarshal(*v, &schedulingPriority)
        if err != nil {
    return err
    }
        jrp.SchedulingPriority = schedulingPriority
    }
                case "dataLocation":
    if v != nil {
        var dataLocation []StorageLocation
        err = json.Unmarshal(*v, &dataLocation)
        if err != nil {
    return err
    }
        jrp.DataLocation = &dataLocation
    }
                case "codeLocation":
    if v != nil {
        var codeLocation StorageLocation
        err = json.Unmarshal(*v, &codeLocation)
        if err != nil {
    return err
    }
        jrp.CodeLocation = &codeLocation
    }
                case "outputLocation":
    if v != nil {
        var outputLocation StorageLocation
        err = json.Unmarshal(*v, &outputLocation)
        if err != nil {
    return err
    }
        jrp.OutputLocation = &outputLocation
    }
                case "frameworkImage":
    if v != nil {
        frameworkImage, err := unmarshalBasicFrameworkImageBase(*v)
    if err != nil {
    return err
    }
        jrp.FrameworkImage = frameworkImage
    }
                case "groupPolicyName":
    if v != nil {
        var groupPolicyName string
        err = json.Unmarshal(*v, &groupPolicyName)
        if err != nil {
    return err
    }
        jrp.GroupPolicyName = &groupPolicyName
    }
                case "checkpointPolicy":
    if v != nil {
        var checkpointPolicy CheckpointPolicy
        err = json.Unmarshal(*v, &checkpointPolicy)
        if err != nil {
    return err
    }
        jrp.CheckpointPolicy = &checkpointPolicy
    }
                case "compilationPolicy":
    if v != nil {
        var compilationPolicy CompilationPolicy
        err = json.Unmarshal(*v, &compilationPolicy)
        if err != nil {
    return err
    }
        jrp.CompilationPolicy = &compilationPolicy
    }
                case "deploymentPolicy":
    if v != nil {
        var deploymentPolicy DeploymentPolicy
        err = json.Unmarshal(*v, &deploymentPolicy)
        if err != nil {
    return err
    }
        jrp.DeploymentPolicy = &deploymentPolicy
    }
                case "maxJobExecutionTime":
    if v != nil {
        var maxJobExecutionTime float64
        err = json.Unmarshal(*v, &maxJobExecutionTime)
        if err != nil {
    return err
    }
        jrp.MaxJobExecutionTime = &maxJobExecutionTime
    }
                case "program":
    if v != nil {
        var program string
        err = json.Unmarshal(*v, &program)
        if err != nil {
    return err
    }
        jrp.Program = &program
    }
                case "programArgs":
    if v != nil {
        var programArgs string
        err = json.Unmarshal(*v, &programArgs)
        if err != nil {
    return err
    }
        jrp.ProgramArgs = &programArgs
    }
                case "tensorBoardLogDirectory":
    if v != nil {
        var tensorBoardLogDirectory string
        err = json.Unmarshal(*v, &tensorBoardLogDirectory)
        if err != nil {
    return err
    }
        jrp.TensorBoardLogDirectory = &tensorBoardLogDirectory
    }
                case "status":
    if v != nil {
        var status JobStatus
        err = json.Unmarshal(*v, &status)
        if err != nil {
    return err
    }
        jrp.Status = status
    }
                case "description":
    if v != nil {
        var description string
        err = json.Unmarshal(*v, &description)
        if err != nil {
    return err
    }
        jrp.Description = &description
    }
                case "statusDetails":
    if v != nil {
        var statusDetails string
        err = json.Unmarshal(*v, &statusDetails)
        if err != nil {
    return err
    }
        jrp.StatusDetails = &statusDetails
    }
                case "notebookEndpoint":
    if v != nil {
        var notebookEndpoint string
        err = json.Unmarshal(*v, &notebookEndpoint)
        if err != nil {
    return err
    }
        jrp.NotebookEndpoint = &notebookEndpoint
    }
                case "tensorBoardEndpoint":
    if v != nil {
        var tensorBoardEndpoint string
        err = json.Unmarshal(*v, &tensorBoardEndpoint)
        if err != nil {
    return err
    }
        jrp.TensorBoardEndpoint = &tensorBoardEndpoint
    }
                case "grafanaEndpoint":
    if v != nil {
        var grafanaEndpoint string
        err = json.Unmarshal(*v, &grafanaEndpoint)
        if err != nil {
    return err
    }
        jrp.GrafanaEndpoint = &grafanaEndpoint
    }
                case "jobLogsEndpoint":
    if v != nil {
        var jobLogsEndpoint string
        err = json.Unmarshal(*v, &jobLogsEndpoint)
        if err != nil {
    return err
    }
        jrp.JobLogsEndpoint = &jobLogsEndpoint
    }
            }
        }

        return nil
        }

        // JobResumeFuture an abstraction for monitoring and retrieving the results of a long-running operation.
        type JobResumeFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *JobResumeFuture) Result(client JobClient) (ar autorest.Response, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.JobResumeFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("microsoftazuremanagementaisupercomputer.JobResumeFuture")
        return
        }
            ar.Response = future.Response()
        return
        }

        // JobSasTokenDescription describes a Shared Access Signature (SAS) Token for Singularity Jobs.
        type JobSasTokenDescription struct {
        autorest.Response `json:"-"`
        // StartTime - The SAS token is valid only after the start time (UTC).
        StartTime *date.Time `json:"startTime,omitempty"`
        // ExpirationTime - The time (UTC) after which the SAS token becomes invalid.
        ExpirationTime *date.Time `json:"expirationTime,omitempty"`
        // Protocol - Possible values include: 'HTTPS', 'TCP', 'WebSocket', 'SSH'
        Protocol ProtocolType `json:"protocol,omitempty"`
        // Version - READ-ONLY; The algorithm and API version the SAS token was generated with
        Version *string `json:"version,omitempty"`
        // Token - READ-ONLY; The SAS token generated by the service.
        Token *string `json:"token,omitempty"`
        // GroupPolicyName - The name of the group policy.
        GroupPolicyName *string `json:"groupPolicyName,omitempty"`
        }

        // MarshalJSON is the custom marshaler for JobSasTokenDescription.
        func (jstd JobSasTokenDescription)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(jstd.StartTime != nil) {
                objectMap["startTime"] = jstd.StartTime
                }
                if(jstd.ExpirationTime != nil) {
                objectMap["expirationTime"] = jstd.ExpirationTime
                }
                if(jstd.Protocol != "") {
                objectMap["protocol"] = jstd.Protocol
                }
                if(jstd.GroupPolicyName != nil) {
                objectMap["groupPolicyName"] = jstd.GroupPolicyName
                }
                return json.Marshal(objectMap)
        }

        // JobSuspendFuture an abstraction for monitoring and retrieving the results of a long-running operation.
        type JobSuspendFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *JobSuspendFuture) Result(client JobClient) (ar autorest.Response, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.JobSuspendFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("microsoftazuremanagementaisupercomputer.JobSuspendFuture")
        return
        }
            ar.Response = future.Response()
        return
        }

        // JobUpdateFuture an abstraction for monitoring and retrieving the results of a long-running operation.
        type JobUpdateFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *JobUpdateFuture) Result(client JobClient) (jrd JobResourceDescription, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.JobUpdateFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("microsoftazuremanagementaisupercomputer.JobUpdateFuture")
        return
        }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if jrd.Response.Response, err = future.GetResult(sender); err == nil && jrd.Response.Response.StatusCode != http.StatusNoContent {
            jrd, err = client.UpdateResponder(jrd.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.JobUpdateFuture", "Result", jrd.Response.Response, "Failure responding to request")
            }
            }
            return
        }

        // JobUserActionDescription describes properties for the user action of Singularity jobs.
        type JobUserActionDescription struct {
        // GroupPolicyName - The name of the group policy.
        GroupPolicyName *string `json:"groupPolicyName,omitempty"`
        }

        // NetworkSettings describes the network settings for the account.
        type NetworkSettings struct {
        // SubnetID - The resource id of the delegated subnet.
        SubnetID *string `json:"subnetId,omitempty"`
        }

        // PlacementPolicy describes the placement policy for a Job or a Model.
        type PlacementPolicy struct {
        // InstanceTypes - The list of settings for instance types.
        InstanceTypes *[]InstanceTypeSettings `json:"instanceTypes,omitempty"`
        // Location - An optional location for instance type placement. If specified, this must be one of the account resource locations.
        Location *string `json:"location,omitempty"`
        }

        // PyTorchFrameworkImage describes a platform PyTorch image for the job resource.
        type PyTorchFrameworkImage struct {
        // Version - Version of the PyTorch image.
        Version *string `json:"version,omitempty"`
        CustomImage *CustomImage `json:"customImage,omitempty"`
        // Kind - Possible values include: 'KindFrameworkImageBase', 'KindTensorFlow', 'KindPyTorch'
        Kind KindBasicFrameworkImageBase `json:"kind,omitempty"`
        }

        // MarshalJSON is the custom marshaler for PyTorchFrameworkImage.
        func (ptfi PyTorchFrameworkImage)MarshalJSON() ([]byte, error){
            ptfi.Kind = KindPyTorch
            objectMap := make(map[string]interface{})
                if(ptfi.Version != nil) {
                objectMap["version"] = ptfi.Version
                }
                if(ptfi.CustomImage != nil) {
                objectMap["customImage"] = ptfi.CustomImage
                }
                if(ptfi.Kind != "") {
                objectMap["kind"] = ptfi.Kind
                }
                return json.Marshal(objectMap)
        }

            // AsTensorFlowFrameworkImage is the BasicFrameworkImageBase implementation for PyTorchFrameworkImage.
            func (ptfi PyTorchFrameworkImage) AsTensorFlowFrameworkImage() (*TensorFlowFrameworkImage, bool) {
                return nil, false
            }

            // AsPyTorchFrameworkImage is the BasicFrameworkImageBase implementation for PyTorchFrameworkImage.
            func (ptfi PyTorchFrameworkImage) AsPyTorchFrameworkImage() (*PyTorchFrameworkImage, bool) {
                return &ptfi, true
            }

            // AsFrameworkImageBase is the BasicFrameworkImageBase implementation for PyTorchFrameworkImage.
            func (ptfi PyTorchFrameworkImage) AsFrameworkImageBase() (*FrameworkImageBase, bool) {
                return nil, false
            }

                // AsBasicFrameworkImageBase is the BasicFrameworkImageBase implementation for PyTorchFrameworkImage.
                func(ptfi PyTorchFrameworkImage) AsBasicFrameworkImageBase()(BasicFrameworkImageBase, bool) {
                    return &ptfi, true
                }


        // Resource the resource model definition for Azure Resource Manager resource.
        type Resource struct {
        // ID - READ-ONLY; Fully qualified identifier for the resource. For example, '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}'
        ID *string `json:"id,omitempty"`
        // Name - READ-ONLY; The name of the resource
        Name *string `json:"name,omitempty"`
        // Type - READ-ONLY; The type of the resource. For example, 'Microsoft.Compute/virtualMachines' or 'Microsoft.Storage/storageAccounts'.
        Type *string `json:"type,omitempty"`
        SystemData *ResourceSystemData `json:"systemData,omitempty"`
        }

        // MarshalJSON is the custom marshaler for Resource.
        func (r Resource)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(r.SystemData != nil) {
                objectMap["systemData"] = r.SystemData
                }
                return json.Marshal(objectMap)
        }

        // ResourceIdentity ...
        type ResourceIdentity struct {
        // Type - The type of identity used for the resource. The type 'None' will remove any identities from the resource.
        Type *string `json:"type,omitempty"`
        // TenantID - READ-ONLY; The tenant id associated with the resource. This property will only be provided for a system assigned identity.
        TenantID *string `json:"tenantId,omitempty"`
        // PrincipalID - READ-ONLY; The principal id of the resource identity. This property will only be provided for a system assigned identity.
        PrincipalID *string `json:"principalId,omitempty"`
        }

        // MarshalJSON is the custom marshaler for ResourceIdentity.
        func (ri ResourceIdentity)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(ri.Type != nil) {
                objectMap["type"] = ri.Type
                }
                return json.Marshal(objectMap)
        }

        // ResourceSystemData ...
        type ResourceSystemData struct {
        // CreatedBy - READ-ONLY; A string identifier for the identity that created the resource.
        CreatedBy *string `json:"createdBy,omitempty"`
        // CreatedByType - READ-ONLY; The type of identity that created the resource: user, application, managedIdentity, key.
        CreatedByType *string `json:"createdByType,omitempty"`
        // CreatedAt - READ-ONLY; The timestamp of resource creation (UTC).
        CreatedAt *string `json:"createdAt,omitempty"`
        // LastModifiedBy - READ-ONLY; A string identifier for the identity that last modified the resource
        LastModifiedBy *string `json:"lastModifiedBy,omitempty"`
        // LastModifiedByType - READ-ONLY; The type of identity that last modified the resource: user, application, managedIdentity, key.
        LastModifiedByType *string `json:"lastModifiedByType,omitempty"`
        // LastModifiedAt - READ-ONLY; The timestamp of resource last modification (UTC).
        LastModifiedAt *string `json:"lastModifiedAt,omitempty"`
        }

        // ScalePolicy describes the scale policy for a Job or a Model.
        type ScalePolicy struct {
        // AutoScale - Indicates if auto scale is enabled.
        AutoScale *bool `json:"autoScale,omitempty"`
        // MinInstanceTypeCount - The minimum instance type count to provision.
        MinInstanceTypeCount *int32 `json:"minInstanceTypeCount,omitempty"`
        // MaxInstanceTypeCount - Maximum instance type count (the limit) up to which to provision.
        MaxInstanceTypeCount *int32 `json:"maxInstanceTypeCount,omitempty"`
        // CurrentInstanceTypeCount - The current instance type count.
        CurrentInstanceTypeCount *int32 `json:"currentInstanceTypeCount,omitempty"`
        // AutoScaleInstanceTypeCountSet - An optional set of valid instance type counts that the job can be autoscaled to e.g., [2,4,8,16]. Min/Max values in the set must be equal to MinInstanceTypeCount/MaxInstanceTypeCount, respectively.
        AutoScaleInstanceTypeCountSet *[]int32 `json:"autoScaleInstanceTypeCountSet,omitempty"`
        // AutoScaleIntervalInSec - The minimum auto scale-up interval in seconds.
        AutoScaleIntervalInSec *int32 `json:"autoScaleIntervalInSec,omitempty"`
        }

        // SchedulingPolicy describes the properties of scheduling policy.
        type SchedulingPolicy struct {
        // SchedulingMode - Possible values include: 'Default', 'Priority', 'FIFO', 'FairShare'
        SchedulingMode SchedulingMode `json:"schedulingMode,omitempty"`
        }

        // StorageContainerCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
        // long-running operation.
        type StorageContainerCreateOrUpdateFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *StorageContainerCreateOrUpdateFuture) Result(client StorageContainerClient) (scrd StorageContainerResourceDescription, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.StorageContainerCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("microsoftazuremanagementaisupercomputer.StorageContainerCreateOrUpdateFuture")
        return
        }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if scrd.Response.Response, err = future.GetResult(sender); err == nil && scrd.Response.Response.StatusCode != http.StatusNoContent {
            scrd, err = client.CreateOrUpdateResponder(scrd.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.StorageContainerCreateOrUpdateFuture", "Result", scrd.Response.Response, "Failure responding to request")
            }
            }
            return
        }

        // StorageContainerDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
        // operation.
        type StorageContainerDeleteFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *StorageContainerDeleteFuture) Result(client StorageContainerClient) (ar autorest.Response, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.StorageContainerDeleteFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("microsoftazuremanagementaisupercomputer.StorageContainerDeleteFuture")
        return
        }
            ar.Response = future.Response()
        return
        }

        // StorageContainerProperties describes the properties of a storage container resource.
        type StorageContainerProperties struct {
        // ProvisioningState - Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled', 'ProvisioningStateCreating', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting'
        ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
        // Description - User-friendly description of the storage container.
        Description *string `json:"description,omitempty"`
        // Tier - Possible values include: 'Cold', 'Warm', 'Hot'
        Tier StorageContainerTier `json:"tier,omitempty"`
        // ConsumedStorageInGB - READ-ONLY; The storage in GB consumed by the storage container.
        ConsumedStorageInGB *int32 `json:"consumedStorageInGB,omitempty"`
        // Status - Possible values include: 'StorageContainerStatusCreating', 'StorageContainerStatusCreated', 'StorageContainerStatusUpdating', 'StorageContainerStatusDeleting', 'StorageContainerStatusSuspending', 'StorageContainerStatusSuspended', 'StorageContainerStatusResuming', 'StorageContainerStatusFailed'
        Status StorageContainerStatus `json:"status,omitempty"`
        // StatusDetails - READ-ONLY; Gives additional information about the current status of the storage container.
        StatusDetails *string `json:"statusDetails,omitempty"`
        // SizeInGB - READ-ONLY; Size of the managed storage in GB
        SizeInGB *int32 `json:"sizeInGB,omitempty"`
        // Location - Location for managed storag.
        Location *string `json:"location,omitempty"`
        }

        // MarshalJSON is the custom marshaler for StorageContainerProperties.
        func (scp StorageContainerProperties)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(scp.ProvisioningState != "") {
                objectMap["provisioningState"] = scp.ProvisioningState
                }
                if(scp.Description != nil) {
                objectMap["description"] = scp.Description
                }
                if(scp.Tier != "") {
                objectMap["tier"] = scp.Tier
                }
                if(scp.Status != "") {
                objectMap["status"] = scp.Status
                }
                if(scp.Location != nil) {
                objectMap["location"] = scp.Location
                }
                return json.Marshal(objectMap)
        }

        // StorageContainerResourceDescription describes a storage container resource in Singularity.
        type StorageContainerResourceDescription struct {
        autorest.Response `json:"-"`
        *StorageContainerResourceDescriptionProperties `json:"properties,omitempty"`
        // ID - READ-ONLY; Fully qualified identifier for the resource. For example, '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}'
        ID *string `json:"id,omitempty"`
        // Name - READ-ONLY; The name of the resource
        Name *string `json:"name,omitempty"`
        // Type - READ-ONLY; The type of the resource. For example, 'Microsoft.Compute/virtualMachines' or 'Microsoft.Storage/storageAccounts'.
        Type *string `json:"type,omitempty"`
        SystemData *ResourceSystemData `json:"systemData,omitempty"`
        }

        // MarshalJSON is the custom marshaler for StorageContainerResourceDescription.
        func (scrd StorageContainerResourceDescription)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(scrd.StorageContainerResourceDescriptionProperties != nil) {
                objectMap["properties"] = scrd.StorageContainerResourceDescriptionProperties
                }
                if(scrd.SystemData != nil) {
                objectMap["systemData"] = scrd.SystemData
                }
                return json.Marshal(objectMap)
        }
        // UnmarshalJSON is the custom unmarshaler for StorageContainerResourceDescription struct.
        func (scrd *StorageContainerResourceDescription) UnmarshalJSON(body []byte) error {
        var m map[string]*json.RawMessage
        err := json.Unmarshal(body, &m)
        if err != nil {
        return err
        }
        for k, v := range  m {
        switch k {
                case "properties":
    if v != nil {
        var storageContainerResourceDescriptionProperties StorageContainerResourceDescriptionProperties
        err = json.Unmarshal(*v, &storageContainerResourceDescriptionProperties)
        if err != nil {
    return err
    }
        scrd.StorageContainerResourceDescriptionProperties = &storageContainerResourceDescriptionProperties
    }
                case "id":
    if v != nil {
        var ID string
        err = json.Unmarshal(*v, &ID)
        if err != nil {
    return err
    }
        scrd.ID = &ID
    }
                case "name":
    if v != nil {
        var name string
        err = json.Unmarshal(*v, &name)
        if err != nil {
    return err
    }
        scrd.Name = &name
    }
                case "type":
    if v != nil {
        var typeVar string
        err = json.Unmarshal(*v, &typeVar)
        if err != nil {
    return err
    }
        scrd.Type = &typeVar
    }
                case "systemData":
    if v != nil {
        var systemData ResourceSystemData
        err = json.Unmarshal(*v, &systemData)
        if err != nil {
    return err
    }
        scrd.SystemData = &systemData
    }
            }
        }

        return nil
        }

        // StorageContainerResourceDescriptionList a pageable list of storage container resources.
        type StorageContainerResourceDescriptionList struct {
        autorest.Response `json:"-"`
        // Value - READ-ONLY; One page of the list.
        Value *[]StorageContainerResourceDescription `json:"value,omitempty"`
        // NextLink - READ-ONLY; URI to fetch the next page of the list.
        NextLink *string `json:"nextLink,omitempty"`
        }

        // StorageContainerResourceDescriptionListIterator provides access to a complete listing of
        // StorageContainerResourceDescription values.
        type StorageContainerResourceDescriptionListIterator struct {
            i int
            page StorageContainerResourceDescriptionListPage
        }
        // NextWithContext advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        func (iter * StorageContainerResourceDescriptionListIterator) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/StorageContainerResourceDescriptionListIterator.NextWithContext")
        defer func() {
        sc := -1
        if iter.Response().Response.Response != nil {
        sc = iter.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        iter.i++
        if iter.i < len(iter. page.Values()) {
        return nil
        }
        err = iter.page.NextWithContext(ctx)
        if err != nil {
        iter. i--
        return err
        }
        iter.i = 0
        return nil
        }
        // Next advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (iter * StorageContainerResourceDescriptionListIterator) Next() error {
        return iter.NextWithContext(context.Background())
        }
        // NotDone returns true if the enumeration should be started or is not yet complete.
        func (iter StorageContainerResourceDescriptionListIterator) NotDone() bool {
        return iter.page.NotDone() && iter.i < len(iter. page.Values())
        }
        // Response returns the raw server response from the last page request.
        func (iter StorageContainerResourceDescriptionListIterator) Response() StorageContainerResourceDescriptionList {
        return iter.page.Response()
        }
        // Value returns the current value or a zero-initialized value if the
        // iterator has advanced beyond the end of the collection.
        func (iter StorageContainerResourceDescriptionListIterator) Value() StorageContainerResourceDescription {
        if !iter.page.NotDone() {
        return StorageContainerResourceDescription{}
        }
        return iter.page.Values()[iter.i]
        }
        // Creates a new instance of the StorageContainerResourceDescriptionListIterator type.
        func NewStorageContainerResourceDescriptionListIterator (page StorageContainerResourceDescriptionListPage) StorageContainerResourceDescriptionListIterator {
            return StorageContainerResourceDescriptionListIterator{page: page}
        }


            // IsEmpty returns true if the ListResult contains no values.
            func (scrdl StorageContainerResourceDescriptionList) IsEmpty() bool {
            return scrdl.Value == nil || len(*scrdl.Value) == 0
            }

            // hasNextLink returns true if the NextLink is not empty.
            func (scrdl StorageContainerResourceDescriptionList) hasNextLink() bool {
            return scrdl.NextLink != nil && len(*scrdl.NextLink) != 0
            }
                // storageContainerResourceDescriptionListPreparer prepares a request to retrieve the next set of results.
                // It returns nil if no more results exist.
                func (scrdl StorageContainerResourceDescriptionList) storageContainerResourceDescriptionListPreparer(ctx context.Context) (*http.Request, error) {
                if !scrdl.hasNextLink() {
                return nil, nil
                }
                return autorest.Prepare((&http.Request{}).WithContext(ctx),
                autorest.AsJSON(),
                autorest.AsGet(),
                autorest.WithBaseURL(to.String( scrdl.NextLink)));
                }

        // StorageContainerResourceDescriptionListPage contains a page of StorageContainerResourceDescription values.
        type StorageContainerResourceDescriptionListPage struct {
            fn func(context.Context, StorageContainerResourceDescriptionList) (StorageContainerResourceDescriptionList, error)
            scrdl StorageContainerResourceDescriptionList
        }

        // NextWithContext advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        func (page * StorageContainerResourceDescriptionListPage) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/StorageContainerResourceDescriptionListPage.NextWithContext")
        defer func() {
        sc := -1
        if page.Response().Response.Response != nil {
        sc = page.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        for {
            next, err := page.fn(ctx, page.scrdl)
            if err != nil {
            return err
            }
            page.scrdl = next
            if !next.hasNextLink() || !next.IsEmpty() {
                break
            }
        }
        return nil
        }

        // Next advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (page * StorageContainerResourceDescriptionListPage) Next() error {
        return page.NextWithContext(context.Background())
        }
        // NotDone returns true if the page enumeration should be started or is not yet complete.
        func (page StorageContainerResourceDescriptionListPage) NotDone() bool {
        return !page.scrdl.IsEmpty()
        }
        // Response returns the raw server response from the last page request.
        func (page StorageContainerResourceDescriptionListPage) Response() StorageContainerResourceDescriptionList {
        return page.scrdl
        }
        // Values returns the slice of values for the current page or nil if there are no values.
        func (page StorageContainerResourceDescriptionListPage) Values() []StorageContainerResourceDescription {
        if page.scrdl.IsEmpty() {
        return nil
        }
        return *page.scrdl.Value
        }
        // Creates a new instance of the StorageContainerResourceDescriptionListPage type.
        func NewStorageContainerResourceDescriptionListPage (getNextPage func(context.Context, StorageContainerResourceDescriptionList) (StorageContainerResourceDescriptionList, error)) StorageContainerResourceDescriptionListPage {
            return StorageContainerResourceDescriptionListPage{fn: getNextPage}
        }

        // StorageContainerResourceDescriptionProperties ...
        type StorageContainerResourceDescriptionProperties struct {
        // ProvisioningState - Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled', 'ProvisioningStateCreating', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting'
        ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
        // Description - User-friendly description of the storage container.
        Description *string `json:"description,omitempty"`
        // Tier - Possible values include: 'Cold', 'Warm', 'Hot'
        Tier StorageContainerTier `json:"tier,omitempty"`
        // ConsumedStorageInGB - READ-ONLY; The storage in GB consumed by the storage container.
        ConsumedStorageInGB *int32 `json:"consumedStorageInGB,omitempty"`
        // Status - Possible values include: 'StorageContainerStatusCreating', 'StorageContainerStatusCreated', 'StorageContainerStatusUpdating', 'StorageContainerStatusDeleting', 'StorageContainerStatusSuspending', 'StorageContainerStatusSuspended', 'StorageContainerStatusResuming', 'StorageContainerStatusFailed'
        Status StorageContainerStatus `json:"status,omitempty"`
        // StatusDetails - READ-ONLY; Gives additional information about the current status of the storage container.
        StatusDetails *string `json:"statusDetails,omitempty"`
        // SizeInGB - READ-ONLY; Size of the managed storage in GB
        SizeInGB *int32 `json:"sizeInGB,omitempty"`
        // Location - Location for managed storag.
        Location *string `json:"location,omitempty"`
        }

        // MarshalJSON is the custom marshaler for StorageContainerResourceDescriptionProperties.
        func (scrd StorageContainerResourceDescriptionProperties)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(scrd.ProvisioningState != "") {
                objectMap["provisioningState"] = scrd.ProvisioningState
                }
                if(scrd.Description != nil) {
                objectMap["description"] = scrd.Description
                }
                if(scrd.Tier != "") {
                objectMap["tier"] = scrd.Tier
                }
                if(scrd.Status != "") {
                objectMap["status"] = scrd.Status
                }
                if(scrd.Location != nil) {
                objectMap["location"] = scrd.Location
                }
                return json.Marshal(objectMap)
        }

        // StorageContainerResourcePatchDescription describes all properties which can be updated for a Singularity
        // storage container resource.
        type StorageContainerResourcePatchDescription struct {
        *StorageContainerResourcePatchDescriptionProperties `json:"properties,omitempty"`
        // ID - READ-ONLY; Fully qualified identifier for the resource. For example, '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}'
        ID *string `json:"id,omitempty"`
        // Name - READ-ONLY; The name of the resource
        Name *string `json:"name,omitempty"`
        // Type - READ-ONLY; The type of the resource. For example, 'Microsoft.Compute/virtualMachines' or 'Microsoft.Storage/storageAccounts'.
        Type *string `json:"type,omitempty"`
        SystemData *ResourceSystemData `json:"systemData,omitempty"`
        }

        // MarshalJSON is the custom marshaler for StorageContainerResourcePatchDescription.
        func (scrpd StorageContainerResourcePatchDescription)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(scrpd.StorageContainerResourcePatchDescriptionProperties != nil) {
                objectMap["properties"] = scrpd.StorageContainerResourcePatchDescriptionProperties
                }
                if(scrpd.SystemData != nil) {
                objectMap["systemData"] = scrpd.SystemData
                }
                return json.Marshal(objectMap)
        }
        // UnmarshalJSON is the custom unmarshaler for StorageContainerResourcePatchDescription struct.
        func (scrpd *StorageContainerResourcePatchDescription) UnmarshalJSON(body []byte) error {
        var m map[string]*json.RawMessage
        err := json.Unmarshal(body, &m)
        if err != nil {
        return err
        }
        for k, v := range  m {
        switch k {
                case "properties":
    if v != nil {
        var storageContainerResourcePatchDescriptionProperties StorageContainerResourcePatchDescriptionProperties
        err = json.Unmarshal(*v, &storageContainerResourcePatchDescriptionProperties)
        if err != nil {
    return err
    }
        scrpd.StorageContainerResourcePatchDescriptionProperties = &storageContainerResourcePatchDescriptionProperties
    }
                case "id":
    if v != nil {
        var ID string
        err = json.Unmarshal(*v, &ID)
        if err != nil {
    return err
    }
        scrpd.ID = &ID
    }
                case "name":
    if v != nil {
        var name string
        err = json.Unmarshal(*v, &name)
        if err != nil {
    return err
    }
        scrpd.Name = &name
    }
                case "type":
    if v != nil {
        var typeVar string
        err = json.Unmarshal(*v, &typeVar)
        if err != nil {
    return err
    }
        scrpd.Type = &typeVar
    }
                case "systemData":
    if v != nil {
        var systemData ResourceSystemData
        err = json.Unmarshal(*v, &systemData)
        if err != nil {
    return err
    }
        scrpd.SystemData = &systemData
    }
            }
        }

        return nil
        }

        // StorageContainerResourcePatchDescriptionProperties ...
        type StorageContainerResourcePatchDescriptionProperties struct {
        // ProvisioningState - Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled', 'ProvisioningStateCreating', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting'
        ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
        // Description - User-friendly description of the storage container.
        Description *string `json:"description,omitempty"`
        // Tier - Possible values include: 'Cold', 'Warm', 'Hot'
        Tier StorageContainerTier `json:"tier,omitempty"`
        // ConsumedStorageInGB - READ-ONLY; The storage in GB consumed by the storage container.
        ConsumedStorageInGB *int32 `json:"consumedStorageInGB,omitempty"`
        // Status - Possible values include: 'StorageContainerStatusCreating', 'StorageContainerStatusCreated', 'StorageContainerStatusUpdating', 'StorageContainerStatusDeleting', 'StorageContainerStatusSuspending', 'StorageContainerStatusSuspended', 'StorageContainerStatusResuming', 'StorageContainerStatusFailed'
        Status StorageContainerStatus `json:"status,omitempty"`
        // StatusDetails - READ-ONLY; Gives additional information about the current status of the storage container.
        StatusDetails *string `json:"statusDetails,omitempty"`
        // SizeInGB - READ-ONLY; Size of the managed storage in GB
        SizeInGB *int32 `json:"sizeInGB,omitempty"`
        // Location - Location for managed storag.
        Location *string `json:"location,omitempty"`
        }

        // MarshalJSON is the custom marshaler for StorageContainerResourcePatchDescriptionProperties.
        func (scrpd StorageContainerResourcePatchDescriptionProperties)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(scrpd.ProvisioningState != "") {
                objectMap["provisioningState"] = scrpd.ProvisioningState
                }
                if(scrpd.Description != nil) {
                objectMap["description"] = scrpd.Description
                }
                if(scrpd.Tier != "") {
                objectMap["tier"] = scrpd.Tier
                }
                if(scrpd.Status != "") {
                objectMap["status"] = scrpd.Status
                }
                if(scrpd.Location != nil) {
                objectMap["location"] = scrpd.Location
                }
                return json.Marshal(objectMap)
        }

        // StorageContainerResumeFuture an abstraction for monitoring and retrieving the results of a long-running
        // operation.
        type StorageContainerResumeFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *StorageContainerResumeFuture) Result(client StorageContainerClient) (scrd StorageContainerResourceDescription, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.StorageContainerResumeFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("microsoftazuremanagementaisupercomputer.StorageContainerResumeFuture")
        return
        }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if scrd.Response.Response, err = future.GetResult(sender); err == nil && scrd.Response.Response.StatusCode != http.StatusNoContent {
            scrd, err = client.ResumeResponder(scrd.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.StorageContainerResumeFuture", "Result", scrd.Response.Response, "Failure responding to request")
            }
            }
            return
        }

        // StorageContainerSuspendFuture an abstraction for monitoring and retrieving the results of a long-running
        // operation.
        type StorageContainerSuspendFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *StorageContainerSuspendFuture) Result(client StorageContainerClient) (scrd StorageContainerResourceDescription, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.StorageContainerSuspendFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("microsoftazuremanagementaisupercomputer.StorageContainerSuspendFuture")
        return
        }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if scrd.Response.Response, err = future.GetResult(sender); err == nil && scrd.Response.Response.StatusCode != http.StatusNoContent {
            scrd, err = client.SuspendResponder(scrd.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.StorageContainerSuspendFuture", "Result", scrd.Response.Response, "Failure responding to request")
            }
            }
            return
        }

        // StorageContainerUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
        // operation.
        type StorageContainerUpdateFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *StorageContainerUpdateFuture) Result(client StorageContainerClient) (scrd StorageContainerResourceDescription, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.StorageContainerUpdateFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("microsoftazuremanagementaisupercomputer.StorageContainerUpdateFuture")
        return
        }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if scrd.Response.Response, err = future.GetResult(sender); err == nil && scrd.Response.Response.StatusCode != http.StatusNoContent {
            scrd, err = client.UpdateResponder(scrd.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "microsoftazuremanagementaisupercomputer.StorageContainerUpdateFuture", "Result", scrd.Response.Response, "Failure responding to request")
            }
            }
            return
        }

        // StorageLocation this type describes a storage location for jobs and services.
        type StorageLocation struct {
        Source BasicStorageSourceBase `json:"source,omitempty"`
        Mount *StorageMount `json:"mount,omitempty"`
        }
        // UnmarshalJSON is the custom unmarshaler for StorageLocation struct.
        func (sl *StorageLocation) UnmarshalJSON(body []byte) error {
        var m map[string]*json.RawMessage
        err := json.Unmarshal(body, &m)
        if err != nil {
        return err
        }
        for k, v := range  m {
        switch k {
                case "source":
    if v != nil {
        source, err := unmarshalBasicStorageSourceBase(*v)
    if err != nil {
    return err
    }
        sl.Source = source
    }
                case "mount":
    if v != nil {
        var mount StorageMount
        err = json.Unmarshal(*v, &mount)
        if err != nil {
    return err
    }
        sl.Mount = &mount
    }
            }
        }

        return nil
        }

        // StorageMount this type describes the mounting properties for a storage source.
        type StorageMount struct {
        // Path - The local mount path for the storage source.
        Path *string `json:"path,omitempty"`
        }

        // StorageSourceAzureAISupercomputerStorage this type describes Singularity storage for a job or service.
        type StorageSourceAzureAISupercomputerStorage struct {
        // StorageContainerName - Path to the Singularity storage.
        StorageContainerName *string `json:"storageContainerName,omitempty"`
        // Kind - Possible values include: 'KindStorageSourceBase', 'KindAzureAISupercomputerStorage', 'KindAzureBlobStorage', 'KindAzureFileStorage'
        Kind Kind `json:"kind,omitempty"`
        }

        // MarshalJSON is the custom marshaler for StorageSourceAzureAISupercomputerStorage.
        func (ssaass StorageSourceAzureAISupercomputerStorage)MarshalJSON() ([]byte, error){
            ssaass.Kind = KindAzureAISupercomputerStorage
            objectMap := make(map[string]interface{})
                if(ssaass.StorageContainerName != nil) {
                objectMap["storageContainerName"] = ssaass.StorageContainerName
                }
                if(ssaass.Kind != "") {
                objectMap["kind"] = ssaass.Kind
                }
                return json.Marshal(objectMap)
        }

            // AsStorageSourceAzureAISupercomputerStorage is the BasicStorageSourceBase implementation for StorageSourceAzureAISupercomputerStorage.
            func (ssaass StorageSourceAzureAISupercomputerStorage) AsStorageSourceAzureAISupercomputerStorage() (*StorageSourceAzureAISupercomputerStorage, bool) {
                return &ssaass, true
            }

            // AsStorageSourceAzureBlob is the BasicStorageSourceBase implementation for StorageSourceAzureAISupercomputerStorage.
            func (ssaass StorageSourceAzureAISupercomputerStorage) AsStorageSourceAzureBlob() (*StorageSourceAzureBlob, bool) {
                return nil, false
            }

            // AsStorageSourceAzureFile is the BasicStorageSourceBase implementation for StorageSourceAzureAISupercomputerStorage.
            func (ssaass StorageSourceAzureAISupercomputerStorage) AsStorageSourceAzureFile() (*StorageSourceAzureFile, bool) {
                return nil, false
            }

            // AsStorageSourceBase is the BasicStorageSourceBase implementation for StorageSourceAzureAISupercomputerStorage.
            func (ssaass StorageSourceAzureAISupercomputerStorage) AsStorageSourceBase() (*StorageSourceBase, bool) {
                return nil, false
            }

                // AsBasicStorageSourceBase is the BasicStorageSourceBase implementation for StorageSourceAzureAISupercomputerStorage.
                func(ssaass StorageSourceAzureAISupercomputerStorage) AsBasicStorageSourceBase()(BasicStorageSourceBase, bool) {
                    return &ssaass, true
                }


        // StorageSourceAzureBlob this type describes Singularity storage for a job or service.
        type StorageSourceAzureBlob struct {
        // BlobEndpoint - Fully qualified url for the specified blob with the associated SAS token.
        BlobEndpoint *string `json:"blobEndpoint,omitempty"`
        // Kind - Possible values include: 'KindStorageSourceBase', 'KindAzureAISupercomputerStorage', 'KindAzureBlobStorage', 'KindAzureFileStorage'
        Kind Kind `json:"kind,omitempty"`
        }

        // MarshalJSON is the custom marshaler for StorageSourceAzureBlob.
        func (ssab StorageSourceAzureBlob)MarshalJSON() ([]byte, error){
            ssab.Kind = KindAzureBlobStorage
            objectMap := make(map[string]interface{})
                if(ssab.BlobEndpoint != nil) {
                objectMap["blobEndpoint"] = ssab.BlobEndpoint
                }
                if(ssab.Kind != "") {
                objectMap["kind"] = ssab.Kind
                }
                return json.Marshal(objectMap)
        }

            // AsStorageSourceAzureAISupercomputerStorage is the BasicStorageSourceBase implementation for StorageSourceAzureBlob.
            func (ssab StorageSourceAzureBlob) AsStorageSourceAzureAISupercomputerStorage() (*StorageSourceAzureAISupercomputerStorage, bool) {
                return nil, false
            }

            // AsStorageSourceAzureBlob is the BasicStorageSourceBase implementation for StorageSourceAzureBlob.
            func (ssab StorageSourceAzureBlob) AsStorageSourceAzureBlob() (*StorageSourceAzureBlob, bool) {
                return &ssab, true
            }

            // AsStorageSourceAzureFile is the BasicStorageSourceBase implementation for StorageSourceAzureBlob.
            func (ssab StorageSourceAzureBlob) AsStorageSourceAzureFile() (*StorageSourceAzureFile, bool) {
                return nil, false
            }

            // AsStorageSourceBase is the BasicStorageSourceBase implementation for StorageSourceAzureBlob.
            func (ssab StorageSourceAzureBlob) AsStorageSourceBase() (*StorageSourceBase, bool) {
                return nil, false
            }

                // AsBasicStorageSourceBase is the BasicStorageSourceBase implementation for StorageSourceAzureBlob.
                func(ssab StorageSourceAzureBlob) AsBasicStorageSourceBase()(BasicStorageSourceBase, bool) {
                    return &ssab, true
                }


        // StorageSourceAzureFile this type describes Singularity storage for a job or service.
        type StorageSourceAzureFile struct {
        // FileEndpoint - Fully qualified endpoint with the file share name.
        FileEndpoint *string `json:"fileEndpoint,omitempty"`
        // StorageAccount - Storage account name for the Azure file share.
        StorageAccount *string `json:"storageAccount,omitempty"`
        // AccountKey - Storage account key for the Azure file share.
        AccountKey *string `json:"accountKey,omitempty"`
        // Kind - Possible values include: 'KindStorageSourceBase', 'KindAzureAISupercomputerStorage', 'KindAzureBlobStorage', 'KindAzureFileStorage'
        Kind Kind `json:"kind,omitempty"`
        }

        // MarshalJSON is the custom marshaler for StorageSourceAzureFile.
        func (ssaf StorageSourceAzureFile)MarshalJSON() ([]byte, error){
            ssaf.Kind = KindAzureFileStorage
            objectMap := make(map[string]interface{})
                if(ssaf.FileEndpoint != nil) {
                objectMap["fileEndpoint"] = ssaf.FileEndpoint
                }
                if(ssaf.StorageAccount != nil) {
                objectMap["storageAccount"] = ssaf.StorageAccount
                }
                if(ssaf.AccountKey != nil) {
                objectMap["accountKey"] = ssaf.AccountKey
                }
                if(ssaf.Kind != "") {
                objectMap["kind"] = ssaf.Kind
                }
                return json.Marshal(objectMap)
        }

            // AsStorageSourceAzureAISupercomputerStorage is the BasicStorageSourceBase implementation for StorageSourceAzureFile.
            func (ssaf StorageSourceAzureFile) AsStorageSourceAzureAISupercomputerStorage() (*StorageSourceAzureAISupercomputerStorage, bool) {
                return nil, false
            }

            // AsStorageSourceAzureBlob is the BasicStorageSourceBase implementation for StorageSourceAzureFile.
            func (ssaf StorageSourceAzureFile) AsStorageSourceAzureBlob() (*StorageSourceAzureBlob, bool) {
                return nil, false
            }

            // AsStorageSourceAzureFile is the BasicStorageSourceBase implementation for StorageSourceAzureFile.
            func (ssaf StorageSourceAzureFile) AsStorageSourceAzureFile() (*StorageSourceAzureFile, bool) {
                return &ssaf, true
            }

            // AsStorageSourceBase is the BasicStorageSourceBase implementation for StorageSourceAzureFile.
            func (ssaf StorageSourceAzureFile) AsStorageSourceBase() (*StorageSourceBase, bool) {
                return nil, false
            }

                // AsBasicStorageSourceBase is the BasicStorageSourceBase implementation for StorageSourceAzureFile.
                func(ssaf StorageSourceAzureFile) AsBasicStorageSourceBase()(BasicStorageSourceBase, bool) {
                    return &ssaf, true
                }


// BasicStorageSourceBase this type describes Singularity storage for a job or service.
        type BasicStorageSourceBase interface {
            AsStorageSourceAzureAISupercomputerStorage () (*StorageSourceAzureAISupercomputerStorage, bool)
            AsStorageSourceAzureBlob () (*StorageSourceAzureBlob, bool)
            AsStorageSourceAzureFile () (*StorageSourceAzureFile, bool)
        AsStorageSourceBase () (*StorageSourceBase, bool)
        }

        // StorageSourceBase this type describes Singularity storage for a job or service.
        type StorageSourceBase struct {
        // Kind - Possible values include: 'KindStorageSourceBase', 'KindAzureAISupercomputerStorage', 'KindAzureBlobStorage', 'KindAzureFileStorage'
        Kind Kind `json:"kind,omitempty"`
        }

        func unmarshalBasicStorageSourceBase(body []byte) (BasicStorageSourceBase, error){
        var m map[string]interface{}
        err := json.Unmarshal(body, &m)
        if err != nil {
        return nil, err
        }

        switch m["kind"] {
            case string(KindAzureAISupercomputerStorage):
            var ssaass StorageSourceAzureAISupercomputerStorage
            err := json.Unmarshal(body, &ssaass)
            return ssaass, err
            case string(KindAzureBlobStorage):
            var ssab StorageSourceAzureBlob
            err := json.Unmarshal(body, &ssab)
            return ssab, err
            case string(KindAzureFileStorage):
            var ssaf StorageSourceAzureFile
            err := json.Unmarshal(body, &ssaf)
            return ssaf, err
                    default:
        var ssb StorageSourceBase
        err := json.Unmarshal(body, &ssb)
        return ssb, err
        }
        }
        func unmarshalBasicStorageSourceBaseArray(body []byte) ([]BasicStorageSourceBase, error){
        var rawMessages []*json.RawMessage
        err := json.Unmarshal(body, &rawMessages)
        if err != nil {
        return nil, err
        }

        ssbArray := make([]BasicStorageSourceBase, len(rawMessages))

        for index, rawMessage := range rawMessages {
        ssb, err := unmarshalBasicStorageSourceBase(*rawMessage)
        if err != nil {
        return nil, err
        }
        ssbArray[index] = ssb
        }
        return ssbArray, nil
        }

        // MarshalJSON is the custom marshaler for StorageSourceBase.
        func (ssb StorageSourceBase)MarshalJSON() ([]byte, error){
            ssb.Kind = KindStorageSourceBase
            objectMap := make(map[string]interface{})
                if(ssb.Kind != "") {
                objectMap["kind"] = ssb.Kind
                }
                return json.Marshal(objectMap)
        }

            // AsStorageSourceAzureAISupercomputerStorage is the BasicStorageSourceBase implementation for StorageSourceBase.
            func (ssb StorageSourceBase) AsStorageSourceAzureAISupercomputerStorage() (*StorageSourceAzureAISupercomputerStorage, bool) {
                return nil, false
            }

            // AsStorageSourceAzureBlob is the BasicStorageSourceBase implementation for StorageSourceBase.
            func (ssb StorageSourceBase) AsStorageSourceAzureBlob() (*StorageSourceAzureBlob, bool) {
                return nil, false
            }

            // AsStorageSourceAzureFile is the BasicStorageSourceBase implementation for StorageSourceBase.
            func (ssb StorageSourceBase) AsStorageSourceAzureFile() (*StorageSourceAzureFile, bool) {
                return nil, false
            }

            // AsStorageSourceBase is the BasicStorageSourceBase implementation for StorageSourceBase.
            func (ssb StorageSourceBase) AsStorageSourceBase() (*StorageSourceBase, bool) {
                return &ssb, true
            }

                // AsBasicStorageSourceBase is the BasicStorageSourceBase implementation for StorageSourceBase.
                func(ssb StorageSourceBase) AsBasicStorageSourceBase()(BasicStorageSourceBase, bool) {
                    return &ssb, true
                }


        // TensorFlowFrameworkImage describes a platform TensorFlow image for the job resource.
        type TensorFlowFrameworkImage struct {
        // Version - Version of the TensorFlow image.
        Version *string `json:"version,omitempty"`
        CustomImage *CustomImage `json:"customImage,omitempty"`
        // Kind - Possible values include: 'KindFrameworkImageBase', 'KindTensorFlow', 'KindPyTorch'
        Kind KindBasicFrameworkImageBase `json:"kind,omitempty"`
        }

        // MarshalJSON is the custom marshaler for TensorFlowFrameworkImage.
        func (tffi TensorFlowFrameworkImage)MarshalJSON() ([]byte, error){
            tffi.Kind = KindTensorFlow
            objectMap := make(map[string]interface{})
                if(tffi.Version != nil) {
                objectMap["version"] = tffi.Version
                }
                if(tffi.CustomImage != nil) {
                objectMap["customImage"] = tffi.CustomImage
                }
                if(tffi.Kind != "") {
                objectMap["kind"] = tffi.Kind
                }
                return json.Marshal(objectMap)
        }

            // AsTensorFlowFrameworkImage is the BasicFrameworkImageBase implementation for TensorFlowFrameworkImage.
            func (tffi TensorFlowFrameworkImage) AsTensorFlowFrameworkImage() (*TensorFlowFrameworkImage, bool) {
                return &tffi, true
            }

            // AsPyTorchFrameworkImage is the BasicFrameworkImageBase implementation for TensorFlowFrameworkImage.
            func (tffi TensorFlowFrameworkImage) AsPyTorchFrameworkImage() (*PyTorchFrameworkImage, bool) {
                return nil, false
            }

            // AsFrameworkImageBase is the BasicFrameworkImageBase implementation for TensorFlowFrameworkImage.
            func (tffi TensorFlowFrameworkImage) AsFrameworkImageBase() (*FrameworkImageBase, bool) {
                return nil, false
            }

                // AsBasicFrameworkImageBase is the BasicFrameworkImageBase implementation for TensorFlowFrameworkImage.
                func(tffi TensorFlowFrameworkImage) AsBasicFrameworkImageBase()(BasicFrameworkImageBase, bool) {
                    return &tffi, true
                }


        // TrackedResource the resource model definition for Azure Resource Manager tracked top-level resource.
        type TrackedResource struct {
        // Location - The geo-location where the resource lives.
        Location *string `json:"location,omitempty"`
        // Tags - Resource tags.
        Tags map[string]*string `json:"tags"`
        // ID - READ-ONLY; Fully qualified identifier for the resource. For example, '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}'
        ID *string `json:"id,omitempty"`
        // Name - READ-ONLY; The name of the resource
        Name *string `json:"name,omitempty"`
        // Type - READ-ONLY; The type of the resource. For example, 'Microsoft.Compute/virtualMachines' or 'Microsoft.Storage/storageAccounts'.
        Type *string `json:"type,omitempty"`
        SystemData *ResourceSystemData `json:"systemData,omitempty"`
        }

        // MarshalJSON is the custom marshaler for TrackedResource.
        func (tr TrackedResource)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(tr.Location != nil) {
                objectMap["location"] = tr.Location
                }
                if(tr.Tags != nil) {
                objectMap["tags"] = tr.Tags
                }
                if(tr.SystemData != nil) {
                objectMap["systemData"] = tr.SystemData
                }
                return json.Marshal(objectMap)
        }

